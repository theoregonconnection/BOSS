<html>
</head>
  <script type='text/javascript' src='https://www.google.com/jsapi'></script>
  <script src="http://ajax.googleapis.com/ajax/libs/jqueryui/1.8.10/jquery-ui.js"></script>
  <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
  <script src="http://jquery-csv.googlecode.com/git/src/jquery.csv.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/2.4.2/math.min.js"></script>
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/2.3.0/math.min.js"></script>
  <script type="text/javascript" src="https://cdn.jsdelivr.net/jstat/1.4.3/jstat.min.js"></script>
  <script type="text/javascript" src="https://www.google.com/jsapi?autoload={'modules':[{'name':'visualization', 'version':'1', 'packages':['corechart']}]}"></script>
 
  
  
<script type='text/javascript'>
///////////Notes and Acknowledgements and License and Disclaimer/////////////
// Experiments conducted by Michael McNamara, Ian Hilgart, Diego Barragan
// Study Design by Michael McNamara, Ian Hilgart, William Redmond, Stefanie Linch
// Data Visualization by Michael McNamara, Ian Hilgart
// Study conducted at EACRI, RWF Cancer Center, Providence Portland Medical Center. March 2015.
// Code by Michael McNamara, Google, HighCharts, Trent Richardson, and many other places on the web.
////Compatible Browsers: Google Chrome.

//License Disclaimer (modified MIT):
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//THE SOFTWARE.

//The license may not give you all of the permissions necessary for your intended use.
//This software uses code developed by Google, HighCharts and others that is subject to 
//additional conditions.For example, some of the components used in this software include licenses that may 
//limit how you use this software. Users may copy, display, make derivatives of, and 
//distribute this software to others for non-commercial purposes, but must maintain the 
//copyright notice above and this permission notice in all copies.



////////////////GLOBAL STUFF////////////
var statusobject = {};
statusobject.status = "Status Info";


///Create Asynch Status Udpate////
function statusupdate() {
		var currentstatus = statusobject.status;
		document.getElementById("selectedpatientinfo").innerHTML = currentstatus;
};


/////STATS PLACEHOLDERS/////////////
/////STATS PLACEHOLDERS/////////////
/////STATS PLACEHOLDERS/////////////
MergedGroupsBOTHARRAYS = [];
MergedGroupsANOVA = [];
MergedGroupsTTest = [];
MergedCohortsBOTHARRAYS = [];
MergedCohortsANOVA = [];
MergedCohortsTTest = [];
MergedTreatmentsANOVA = [];
MergedTreatmentsTTest = [];
MergedTreatmentsBOTHARRAYS = [];

///Aquire Screen Size
$(function () {
var ScreenWidth = window.screen.availWidth;
var ScreenWidth = ScreenWidth * 0.9;

var ScreenHeight = window.screen.availHeight;
var ScreenHeight = ScreenHeight * 0.85;

$("#bigcontainer").width(ScreenWidth).height(ScreenHeight);


//////Toggle Buttons for Selection and Stats DIVS
/////Show or Hide Base Options
$("#hidebaseoptions").click(function(){
		$("#minimizebaseoptions").toggle();
		$("#maximizebaseoptions").toggle();
		$("#baseoptionsdiv").toggle();
	});
$("#showbaseoptions").click(function(){
		$("#minimizebaseoptions").toggle();
		$("#maximizebaseoptions").toggle();
		$("#baseoptionsdiv").toggle();
	});

/////Show or Hide Cohort Stats
$("#hidecohortstats").click(function(){
		$("#minimizecohortstats").toggle();
		$("#maximizecohortstats").toggle();
		$("#expandedselectors").toggle();
	});
$("#showcohortstats").click(function(){
		$("#minimizecohortstats").toggle();
		$("#maximizecohortstats").toggle();
		$("#expandedselectors").toggle();
	});

/////Show or Hide Treatment Stats
$("#hidetreatmentstats").click(function(){
		$("#minimizetreatmentstats").toggle();
		$("#maximizetreatmentstats").toggle();
		$("#treatmentgroupsdiv").toggle();
	});
$("#showtreatmentstats").click(function(){
		$("#minimizetreatmentstats").toggle();
		$("#maximizetreatmentstats").toggle();
		$("#treatmentgroupsdiv").toggle();
	});

//////Toggle Buttons for Selection and Stats DIVS
/////Show or Hide Drop Down DIVs (COLUMN CHART UPDATE)////
/////Show or Hide Drop Down DIVs (COLUMN CHART UPDATE)////
$("#hidecohorts").click(function(){
		$("#cohortsVISIBLE").toggle();
		$("#cohortsHIDDEN").toggle();
		$("#cohortstatsandoptions").toggle();
	});
$("#showcohorts").click(function(){
		$("#cohortsVISIBLE").toggle();
		$("#cohortsHIDDEN").toggle();
		$("#cohortstatsandoptions").toggle();
	});
/////Show or Hide Treatment Stats
$("#hidetreatments").click(function(){
		$("#treatmentsVISIBLE").toggle();
		$("#treatmentsHIDDEN").toggle();
		$("#treatmentstatsandoptions").toggle();
	});
$("#showtreatments").click(function(){
		$("#treatmentsVISIBLE").toggle();
		$("#treatmentsHIDDEN").toggle();
		$("#treatmentstatsandoptions").toggle();
	});
/////Show or Hide Group Selectors and Stats
$("#hidegroups").click(function(){
		$("#groupsVISIBLE").toggle();
		$("#groupsHIDDEN").toggle();
		$("#groupstatsandoptions").toggle();
	});
$("#showgroups").click(function(){
		$("#groupsVISIBLE").toggle();
		$("#groupsHIDDEN").toggle();
		$("#groupstatsandoptions").toggle();
	});







});



$(document).ready(function() {
	statusupdate();
	if(isAPIAvailable()) {

	  $('#files').bind('change', handleFileSelect);
    }
	
		//////////Alert if Wrong Browser Type (not using Chrome)///////////
	var isChrome = !!window.chrome && !isOpera; 

	if (isChrome !== true)
		{
			alert("You should be using Google Chrome. Some features may not work properly with other browsers");
		}
  });

  function isAPIAvailable() {
    // Check for the various File API support.
    if (window.File && window.FileReader && window.FileList && window.Blob) {
      // Great success! All the File APIs are supported.
      return true;
    } else {
      // source: File API availability - http://caniuse.com/#feat=fileapi
      // source: <output> availability - http://html5doctor.com/the-output-element/
      document.writeln('The HTML5 APIs used in this form are only available in the following browsers:<br />');
      // 6.0 File API & 13.0 <output>
      document.writeln(' - Google Chrome: 13.0 or later<br />');
      // 3.6 File API & 6.0 <output>
      document.writeln(' - Mozilla Firefox: 6.0 or later<br />');
      // 10.0 File API & 10.0 <output>
      document.writeln(' - Internet Explorer: Not supported (partial support expected in 10.0)<br />');
      // ? File API & 5.1 <output>
      document.writeln(' - Safari: Not supported<br />');
      // ? File API & 9.2 <output>
      document.writeln(' - Opera: Not supported');
      return false;
    }
  }

/////Process Uploaded CSV File///////////////
  function handleFileSelect(evt) {
    statusobject.status = "Processing Uploaded File";
	statusupdate();
	var files = evt.target.files; // FileList object
    var file = files[0];

    // read the file metadata
    var FileName = escape(file.name);
	var FileType = file.type;
	var FileSize = file.size;
    // read the file contents
    setTimeout(structureJavaScriptArray(file), 200);;
  }

////Placeholder array
var newbasearray =  [];

/////Read CSV file to Javascript Array
function structureJavaScriptArray(file) {
    statusobject.status = "Converting File to Javascript Array";
	statusupdate();
	var reader = new FileReader();
    reader.readAsText(file);
    reader.onload = function(event){
      var csv = event.target.result;
      var data = $.csv.toArrays(csv);
	  var update = document.getElementById("update");
	  var newbasearray = data;
	  statusobject.status = "Analyzing Javascript Array";
	  analyzeArray(newbasearray);
	  
    };
    reader.onerror = function(){ alert('Unable to read ' + file.fileName); };	
}



/////////Style Arrays////////
var cancertypeshapesarray = ['circle','square','triangle','diamond','star','polygon','circle','circle','circle','circle','circle','circle'];
var cancertypeshapesarrayhtmlcodes = ['&#9679;','&#9632;','&#9650;','&#9670;','&#9733;','&#9751;','&#9679;','&#9679;','&#9679;','&#9679;','&#9679;','&#9679;'];
var treatmentcolorsarray = ['gray','fuchsia','aqua','maroon','navy','lime','teal','olive','purple','blue','red','yellow','green'];
var cancertypecolorsarray = ['blue','red','green','yellow','purple','olive','teal','lime','navy','aqua','fuchsia','maroon'];
var cancertreatpairsselectionformat = [[null,null,null]];

/////////FUNCTIONS//////////
/////////FUNCTIONS//////////
/////////FUNCTIONS//////////
/////////FUNCTIONS//////////
/////////FUNCTIONS//////////


////STATS FUNCTIONS////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////STATS FUNCTIONS////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////STATS FUNCTIONS////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////STATS FUNCTIONS////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////STATS FUNCTIONS////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////STATS FUNCTIONS////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////STATS FUNCTIONS////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////STATS FUNCTIONS////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////Welch's T Test//////
function welchttest(firstsamplemean, firstsamplestandarddeviation, firstsamplesize, secondsamplemean, secondsamplestandarddeviation, secondsamplesize ) {
	
	var tvaluenumerator = firstsamplemean - secondsamplemean;
	var firstsamplevariance = firstsamplestandarddeviation * firstsamplestandarddeviation;
	var secondsamplevariance = secondsamplestandarddeviation * secondsamplestandarddeviation;
	var tvaluedenominator = (firstsamplevariance / firstsamplesize ) + (secondsamplevariance / secondsamplesize );
	var tvaluedenominator = math.sqrt(tvaluedenominator);
	var tscore = tvaluenumerator / tvaluedenominator;
	return tscore;
}

////Linear Regression Analysis////
////Linear Regression Function (from Trent Richardson)////
////Linear Regression Function (from Trent Richardson)////
////Returns
//var lr = linearRegression(known_y, known_x);
// now you have:
// lr.slope
// lr.intercept
// lr.r2
function linearRegression(y,x){
		var lr = {};
		var n = y.length;
		var sum_x = 0;
		var sum_y = 0;
		var sum_xy = 0;
		var sum_xx = 0;
		var sum_yy = 0;
		
		for (var i = 0; i < y.length; i++) {
			
			sum_x += x[i];
			sum_y += y[i];
			sum_xy += (x[i]*y[i]);
			sum_xx += (x[i]*x[i]);
			sum_yy += (y[i]*y[i]);
		} 
		
		lr['slope'] = (n * sum_xy - sum_x * sum_y) / (n*sum_xx - sum_x * sum_x);
		lr['intercept'] = (sum_y - lr.slope * sum_x)/n;
		lr['r2'] = Math.pow((n*sum_xy - sum_x*sum_y)/Math.sqrt((n*sum_xx-sum_x*sum_x)*(n*sum_yy-sum_y*sum_y)),2);
		
		return lr;
}


//////Calculate Linear Regression, Outlier De-weighted Linear Regression and P Value From 2 paired arrays/////
//////Calculate Linear Regression, Outlier De-weighted Linear Regression and P Value From 2 paired arrays/////
function calculatelinearregressionandpvalue(XaxisOutcome, YaxisParameter, SelectedOutcome, SelectedPopulation) {
		
	if (XaxisOutcome.length == YaxisParameter.length)
		{	
			var CorrelationInputArray = [];
			
			var SampleSize = XaxisOutcome.length;	
			if (isNaN(SampleSize) == true)
				{
					var SampleSize = 0;
				}
				
			var SampleSizeCoEfficient = 1;
			var lr = linearRegression(YaxisParameter,XaxisOutcome);
			var roundedr2 = Math.round(lr.r2 * 10000) / 10000;
			var CheckIfValid = isNaN(roundedr2);
			if (roundedr2 > 1 || roundedr2 < 0 || CheckIfValid == true)
				{roundedr2 = 0;}
			
			/////Calculate P Value
			var tempslope = lr.slope;
			if (isNaN(tempslope) == true)
				{
					var tempslope = 0;
				}
			var tempintercept = lr.intercept;
			if (isNaN(tempintercept) == true)
				{
					var tempintercept = 0;
				}
			var tempPvalue = linearregressionpvalue(YaxisParameter,XaxisOutcome,tempslope,tempintercept);
			if (isNaN(tempPvalue) == true || roundedr2 == 0 || roundedr2 == 1)
				{
					var tempPvalue = 1;
				}
			
			////Single Level Outlier Adjusted 1r2 Value
			CombinedArray = [];
			var combinedarraycount = 0;
			while (combinedarraycount < YaxisParameter.length)
				{
					var YValue = YaxisParameter[combinedarraycount];
					var XValue = XaxisOutcome[combinedarraycount];
					CombinedArray.push([YValue, XValue]);
					combinedarraycount++;
				}
			
			CombinedArray.sort(function(a,b){
				// each value in this array is an array
				// the 0th position has what we want to sort on
				// Date objects are represented as a timestamp when converted to numbers
				return a[0] - b[0];
			});
			CombinedArray.pop();
			CombinedArray.shift();

			CombinedArray.sort(function(a,b){
				return a[1] - b[1];
			});							
			CombinedArray.pop();
			CombinedArray.shift();

			var combinedarraycount = 0;
			var AdjustedYValues = [];
			var AdjustedXValues = [];
			while (combinedarraycount < CombinedArray.length)
				{
					AdjustedYValues.push(CombinedArray[combinedarraycount][0]);
					AdjustedXValues.push(CombinedArray[combinedarraycount][1]);
					combinedarraycount++;
				}							

			var OutlierAdjusted = linearRegression(AdjustedYValues,AdjustedXValues);
			var OutlierAdjustedRoundedr2 = Math.round(OutlierAdjusted.r2 * 10000) / 10000;
			var CheckIfValidADJUSTED = isNaN(OutlierAdjustedRoundedr2);
			if (OutlierAdjustedRoundedr2 < 0 || OutlierAdjustedRoundedr2 > 1 || CheckIfValidADJUSTED == true)
				{
					var OutlierAdjustedRoundedr2 = 0;
				}
			
			var composite = (OutlierAdjustedRoundedr2 * 0.25) + (roundedr2 * 0.75);
			var compositerounded = Math.round(composite * 10000) / 10000;
			if (isNaN(compositerounded) == true)
				{
					var compositerounded = 0;
				}				
				
			CorrelationInputArray.push(tempPvalue, roundedr2, compositerounded, tempslope, tempintercept, SampleSize);
			
			return CorrelationInputArray;
			
		}
		
	}



////Define P Value of Line of Best Fit
function linearregressionpvalue(YaxisParameter, XaxisOutcome, slope, intercept) {


	/////Calculate P Value
	SampleYValuesMean = math.mean(YaxisParameter);
	SampleYValuesMin = math.min(YaxisParameter);
	SampleYValuesMax = math.max(YaxisParameter);
		
		////Loop Value to create arrays of probabilities
		var PredictedProbabilities = [];
		var NullProbabilities = [];
		var PValueLoopCount = 0;
		while (PValueLoopCount < YaxisParameter.length)
			{
				var tempSampleY = YaxisParameter[PValueLoopCount];
				var tempSampleX = XaxisOutcome[PValueLoopCount];
				
				var PredictedYValue = (slope * tempSampleX) + intercept;
				var PredictedYValuetoMax = SampleYValuesMax - PredictedYValue;
				var PredictedYValuetoMin = PredictedYValue - SampleYValuesMin;
				var MaximimumRangeForPredictedValue = math.max([PredictedYValuetoMax,PredictedYValuetoMin]);

				var NullYValuetoMax = SampleYValuesMax - SampleYValuesMean;
				var NullYValuetoMin = SampleYValuesMean - SampleYValuesMin;
				var MaximimumRangeForNullValue = math.max([NullYValuetoMax,NullYValuetoMin]);
													
				var RealDifferenceBetweenActualAndPredicted = math.abs(tempSampleY - PredictedYValue);
				var RealDifferenceBetweenActualAndNull = math.abs(tempSampleY - SampleYValuesMean);

				var ProbabilityOfProximitytoPredicted = RealDifferenceBetweenActualAndPredicted / MaximimumRangeForPredictedValue;
				var ProbabilityOfProximitytoNull = RealDifferenceBetweenActualAndNull / MaximimumRangeForNullValue;
				
				PredictedProbabilities.push(ProbabilityOfProximitytoPredicted);
				NullProbabilities.push(ProbabilityOfProximitytoNull);
				
				PValueLoopCount++;
			}
				
	
		/////Run T Test on the Probabilities of Predicted vs Null
		var NullProbMean = math.mean(NullProbabilities);
		var NullProbStandardDeviation = math.std(NullProbabilities);
		var NullProbSampleSize = NullProbabilities.length;

		var PredictedProbMean = math.mean(PredictedProbabilities);
		var PredictedProbStandardDeviation = math.std(PredictedProbabilities);
		var PredictedProbSampleSize = PredictedProbabilities.length;

		var tempTscore = welchttest(PredictedProbMean,  PredictedProbStandardDeviation, PredictedProbSampleSize, NullProbMean, NullProbStandardDeviation, NullProbSampleSize);
		var tempTscore = math.round(tempTscore * 10000) / 10000;
		var tempPvalue = jStat.ttest(tempTscore, PredictedProbSampleSize, 2);
		var tempPvalue = math.round(tempPvalue * 10000000000000000) / 10000000000000000;
		
		///Error check tempPvalue
		if (isNaN(tempPvalue) == true || tempPvalue < 0 || tempPvalue > 1)
			{
				tempPvalue = 1;
			}
		return tempPvalue;

	}


///////Calculate Means, STD Deviations and Intervals for Data Sets//////

function calculatemeanandintervals(tempvaluescollection) {
	
	if (tempvaluescollection.length < 1)
		{
			var tempMEAN = null;
			var tempLOWINTERVAL = null;
			var tempHIGHINTERVAL = null;
		}

	if (tempvaluescollection.length == 1)
		{
			var tempMEAN = tempvaluescollection[0];
			var tempMEAN = Math.round(tempMEAN * 100) / 100;
			var tempLOWINTERVAL = null;
			var tempHIGHINTERVAL = null;
		}

	if (tempvaluescollection.length == 2)
		{
			var tempMEAN = math.mean(tempvaluescollection);
			var tempMEAN = Math.round(tempMEAN * 100) / 100;
			var tempSTD = Math.abs(tempvaluescollection[0] - tempvaluescollection[1]);
			var tempSTD = Math.round(tempSTD * 100) / 100;
			var tempHIGHINTERVAL = tempMEAN + tempSTD;
			var tempHIGHINTERVAL = Math.round(tempHIGHINTERVAL * 100);
			var tempHIGHINTERVAL = tempHIGHINTERVAL / 100;
			var tempLOWINTERVAL = tempMEAN - tempSTD;
			var tempLOWINTERVAL = Math.round(tempLOWINTERVAL * 100);
			var tempLOWINTERVAL = tempLOWINTERVAL / 100;			
			
			if (tempMEAN < 0)
				{
					if (tempHIGHINTERVAL > 0)
						{
							tempHIGHINTERVAL = 0;
						}
				}
				
			if (tempMEAN > 0)
				{
					if (tempLOWINTERVAL < 0)
						{
							tempLOWINTERVAL = 0;
						}
				}
		}

	if (tempvaluescollection.length > 2)
		{
			var tempMEAN = math.mean(tempvaluescollection);
			var tempMEAN = Math.round(tempMEAN * 100) / 100;
			var tempSTD = math.std(tempvaluescollection);
			var tempSTD = Math.round(tempSTD * 100) / 100;
			var tempHIGHINTERVAL = tempMEAN + tempSTD;
			var tempHIGHINTERVAL = Math.round(tempHIGHINTERVAL * 100);
			var tempHIGHINTERVAL = tempHIGHINTERVAL / 100;
			var tempLOWINTERVAL = tempMEAN - tempSTD;
			var tempLOWINTERVAL = Math.round(tempLOWINTERVAL * 100);
			var tempLOWINTERVAL = tempLOWINTERVAL / 100;			
			
			if (tempMEAN < 0)
				{
					if (tempHIGHINTERVAL > 0)
						{
							tempHIGHINTERVAL = 0;
						}
				}
				
			if (tempMEAN > 0)
				{
					if (tempLOWINTERVAL < 0)
						{
							tempLOWINTERVAL = 0;
						}
				}
		}
	
	var meanandstdcalculations = [tempMEAN, tempSTD, tempLOWINTERVAL, tempHIGHINTERVAL];
	
	return meanandstdcalculations;
}



//////Calculate ANOVA With Max Mean Difference and P Value//////
//////Calculate ANOVA With Max Mean Difference and P Value//////
//////Calculate ANOVA With Max Mean Difference and P Value//////

function calculateANOVAwithmaxdifference(inputarrays) {
	
	if (inputarrays.length > 2 && isNaN(inputarrays[0][0]) == false)
		{
			var count = 0;
			var tempmeanslist = [];
			while (count < inputarrays.length)
				{
					var tempindividualarray = inputarrays[count];
					if (tempindividualarray.length > 0)
						{
							var tempindividualmean = jStat.mean(tempindividualarray);
							tempmeanslist.push(tempindividualmean);
						}		
					count++;
				}

			var tempmaxmean = jStat.max(tempmeanslist);
			var tempminmean = jStat.min(tempmeanslist);
			var tempmaxdifference = tempmaxmean - tempminmean;
			var tempmaxdifference = tempmaxdifference * 100;
			var tempmaxdifference = Math.round(tempmaxdifference);
			var tempmaxdifference = tempmaxdifference / 100;
			
			var ANOVAFScore = jStat.anovafscore(inputarrays);
			var ANOVAFScore = Math.round(ANOVAFScore * 10000) / 10000;
			var ANOVAPValue = jStat.anovaftest(ANOVAFScore, 4, 4);
			var ANOVAPValue = Math.round(ANOVAPValue * 1000000000000) / 1000000000000;
			if (ANOVAPValue < 0 || ANOVAPValue > 1 || isNaN(ANOVAPValue) == true)
				{
					ANOVAPValue = 1;
				}
			
			var tempANOVAinsert = [ANOVAPValue, ANOVAFScore, tempmaxdifference];
		}
	else
		{
			var tempANOVAinsert = [null, null, null];
		}
	return tempANOVAinsert;
}


////Prepare and Run ANOVA Analysis on GROUPS/// 
////Prepare and Run ANOVA Analysis on GROUPS/// 
function analyzegroupsattimepointparameterANOVA(MasterTreatmentCohortArray, timepointlist, treatmentlist, groupslist, groupsparentchildlist, populationlist, outcomeslist, cancertypetreatmentpairlist) {
	
	var concatenatedpopulationoutcomeslist = populationlist.concat(outcomeslist);
	//alert(concatenatedpopulationoutcomeslist);
	
	var finalresultarray = [["P Value", "F Score", "Max Difference", "Timepoint", "Treatment", "Parameter", "Group Parent"]]; 
	var finalresultarrayTTest = [["P Value", "T Score","Target Population", "Reference Population", "Difference", "Target Mean", "Reference Mean", "Timepoint", "Treatment", "Parameter"]];
	///individualTTestArray -> [[PValue, TScore, combinedarraylistlegend[count2], combinedarraylistlegend[count], difference, targetmean, referencemean, temptimepoint, temptreatment, tempparameter]];
	
	var groupswithatleastthreesubsets = [];
	var groupswithatleasttwosubsets = [];
	
	var count = 0;
	while (count < groupslist.length)
		{
			var tempparent = groupslist[count];
			var parentchecker = 0;	
				
			var count2 = 0;
			while (count2 < groupsparentchildlist.length)
				{
					var tempparentchild = groupsparentchildlist[count2];
					if (tempparentchild.indexOf(tempparent) > -1)
						{
							parentchecker++;
						}
					count2++;
				}
			
			if (parentchecker > 2)
				{
					groupswithatleastthreesubsets.push(tempparent);
				}
			if (parentchecker > 1)
				{
					groupswithatleasttwosubsets.push(tempparent);
				}

			count++;
		}
		
	if (groupswithatleasttwosubsets.length > 0)
		{			
			
			var count = 0;
			while (count < timepointlist.length)
				{
					var temptimepoint = timepointlist[count];
					var temptimepoint = String(temptimepoint);
					
					var count2 = 0; 
					while (count2 < treatmentlist.length)
						{
							var temptreatment = treatmentlist[count2];	
							
							var countP = 0;
							while (countP < concatenatedpopulationoutcomeslist.length)
								{
									var tempparameter = concatenatedpopulationoutcomeslist[countP];
									
										var count3 = 0;
										while (count3 < groupswithatleasttwosubsets.length)
											{
												
												var combinedarraylist = [];
												var combinedarraylistlegend = [];
												
												var tempgroup = groupswithatleasttwosubsets[count3];
												var tempgroup = String(tempgroup);
												
												var count4 = 0;
												while (count4 < MasterTreatmentCohortArray.length)
													{
														
														var groupssubsetarraylist = [];
														var tempheaderrow = MasterTreatmentCohortArray[0];
														
														var temprow = MasterTreatmentCohortArray[count4];
														var groupcheck = temprow[2].indexOf(tempgroup);
														//alert(temprow[0] + "  " + temptimepoint + "  " + temprow[1] + "  " + temptreatment + "  " + groupcheck);
														
														if (temprow[0] == temptimepoint && groupcheck > -1 && temprow[1] == "ALL")
															{								
																var count5 = 0;
																while (count5 < tempheaderrow.length)
																	{																														
																		var tempselectedheader = tempheaderrow[count5];
																		var tempselectedheader = String(tempselectedheader);
																		var targetheader = "Composite - " + temptreatment + ": " + tempparameter;										
																		
																		if (tempselectedheader == targetheader)
																			{								
																				var tempALLVALUESposition = count5 + 1;
																				var tempALLVALUESdata = temprow[tempALLVALUESposition];
																				if (tempALLVALUESdata.length > 0 && isNaN(tempALLVALUESdata[0]) == false)
																					{
																						combinedarraylist.push(tempALLVALUESdata);
																						combinedarraylistlegend.push(temprow[2]);
																					}
																				var count5 = 999999999999;
																			}
																		count5++;
																	}
															}											
																								
														count4++;
													}
												
												if (combinedarraylist.length > 2)
													{
														var ANOVAanalysis = calculateANOVAwithmaxdifference(combinedarraylist);
														var tempinsert = [ANOVAanalysis[0], ANOVAanalysis[1], ANOVAanalysis[2], temptimepoint, temptreatment, tempparameter, tempgroup];
														finalresultarray.push(tempinsert);
													}

												if (combinedarraylist.length > 1)
													{
														var TTestanalysis = calculateTTestwithmaxdifference(combinedarraylist, combinedarraylistlegend);
														///Returns Array of Arrays -> [[PValue, TScore, combinedarraylistlegend[count2], combinedarraylistlegend[count], difference, targetmean, referencemean]];
														
														var countT = 0;
														while (countT < TTestanalysis.length)
															{
																var individualTTestArray = TTestanalysis[countT];
																individualTTestArray.push(temptimepoint, temptreatment, tempparameter);
																finalresultarrayTTest.push(individualTTestArray);
																///individualTTestArray -> [[PValue, TScore, combinedarraylistlegend[count2], combinedarraylistlegend[count], difference, targetmean, referencemean, temptimepoint, temptreatment, tempparameter]];
																countT++;
															}
														
													}

																
												count3++;
											}
									countP++;
								}
								
							count2++;
						}
					count++;
				}
		}
		
	if (finalresultarray.length > 1)
		{
			finalresultarray.sort(function(a,b){
				return a[0] - b[0];
			});
		}
	else 
		{
			finalresultarray = null;
		}
	
	if (finalresultarrayTTest.length > 1)
		{
			finalresultarrayTTest.sort(function(a,b){
				return a[0] - b[0];
			});
		}
	else 
		{
			finalresultarrayTTest = null;
		}	
	
	var botharrays = [finalresultarray, finalresultarrayTTest];
	return botharrays;

}



////Calculate T Test and Max Differences from Array of Arrays/////
////Calculate T Test and Max Differences from Array of Arrays/////
function calculateTTestwithmaxdifference(combinedarraylist, combinedarraylistlegend) {

	var relationshipsarray = [];	
	var count = 0;
	while (count < combinedarraylist.length)
		{
			var referencearray = combinedarraylist[count];
			
			var count2 = 0;
			while (count2 < combinedarraylist.length)
				{
					var singlerelationship = [];
					var targetarray = combinedarraylist[count2];

					if (count !== count2)
						{

							var referencemean = math.mean(referencearray);
							var referencemean = Math.round(referencemean * 100) / 100;
							
							var targetmean = math.mean(targetarray);
							var targetmean = Math.round(targetmean * 100) / 100;
							var difference = targetmean - referencemean;
							var difference = Math.round(difference * 100) / 100;
							
							if (difference > -0.0000000000000001)
								{
									
									var referencestandarddeviation = math.std(referencearray);
									var referencestandarddeviation = Math.round(referencestandarddeviation * 1000) / 1000;
									var targetstandarddeviation = math.std(targetarray);
									var targetstandarddeviation = Math.round(targetstandarddeviation * 1000) / 1000;
									//alert(referencemean + " " + referencestandarddeviation + " " + referencearray.length + " " + targetmean + " " + targetstandarddeviation + " " + targetarray.length);	
									var TScore = welchttest(referencemean, referencestandarddeviation, referencearray.length, targetmean, targetstandarddeviation, targetarray.length)
									var TScore = Math.round(TScore * 10000) / 10000;
									var PValue = jStat.ttest(TScore, (referencearray.length - 1), 2);
									var PValue = Math.round(PValue * 10000000000000000) / 10000000000000000;
									//alert(PValue + " " + TScore + " " + combinedarraylistlegend[count2] + " " + combinedarraylistlegend[count] + " " + difference + " " + targetmean + " " + referencemean);
									
									
									if (PValue > 0 && PValue < 1)
										{
											var singlerelationship = [PValue, TScore, combinedarraylistlegend[count2], combinedarraylistlegend[count], difference, targetmean, referencemean];
											
											relationshipsarray.push(singlerelationship);
										}
								}
							}
					count2++;
				}
			count++;
		}
	
	//alert(relationshipsarray);
	return relationshipsarray;
}
		

////Prepare and Run ANOVA Analysis on COHORTS///
////Prepare and Run ANOVA Analysis on COHORTS/// 
function analyzecohortsattimepointparameterANOVA(MasterTreatmentCohortArray, timepointlist, treatmentlist, groupslist, groupsparentchildlist, populationlist, outcomeslist, cancertypetreatmentpairlist) {
	
	
	var concatenatedpopulationoutcomeslist = populationlist.concat(outcomeslist);
	//alert(concatenatedpopulationoutcomeslist);
	
	var finalresultarray = [["P Value", "F Score", "Max Difference", "Timepoint", "Treatment", "Parameter", "Group Parent"]];
	var finalresultarrayTTest = [["P Value", "T Score","Target Population", "Reference Population", "Difference", "Target Mean", "Reference Mean", "Timepoint", "Treatment", "Parameter"]];
	var cohortswithatleasttwosubsets = [];
	var tempgroup = "ALL";
		
	if (cancertypetreatmentpairlist.length > 2)
		{
			var count = 0;
			while (count < timepointlist.length)
				{
					var temptimepoint = timepointlist[count];
					var temptimepoint = String(temptimepoint);
					
					var count2 = -1; 
					while (count2 < 0)
						{
							
							var temptreatment = "ALL";	
							
							var countP = 0;
							while (countP < concatenatedpopulationoutcomeslist.length)
								{
									var tempparameter = concatenatedpopulationoutcomeslist[countP];
									var combinedarraylist = [];
									var combinedarraylistlegend = [];
																					
										var count3 = 0;
										while (count3 < cancertypetreatmentpairlist.length)
											{
												

												var tempcohort = cancertypetreatmentpairlist[count3];
												var tempcohort = String(tempcohort);
												
												var count4 = 0;
												while (count4 < MasterTreatmentCohortArray.length)
													{
														var tempheaderrow = MasterTreatmentCohortArray[0];
														var temprow = MasterTreatmentCohortArray[count4];
														
														
														if (temprow[0] == temptimepoint && temprow[1] == temptreatment && temprow[2] == "ALL")
															{
																
																var cohortarray = [];
																var count5 = 0;
																while (count5 < tempheaderrow.length)
																	{																														
																		
																		var tempselectedheader = tempheaderrow[count5];
																		var tempselectedheader = String(tempselectedheader);
																		var headercohortcheck = tempselectedheader.indexOf(tempcohort);
																		var headercheck = tempselectedheader.indexOf(tempparameter);
														
																		if (headercheck > -1 && headercohortcheck > -1)
																			{
																				
																				var tempALLVALUESposition = count5 + 1;
																				var tempALLVALUESdata = temprow[tempALLVALUESposition];
																				if (tempALLVALUESdata.length > 0 && isNaN(tempALLVALUESdata[0]) == false)
																					{
																						var cohortarray = tempALLVALUESdata;
																					}
																				var count5 = 9999999999999;
																			}
																		count5++;
																	}
															
																if (cohortarray.length > 0)
																	{
																		combinedarraylist.push(cohortarray);
																		combinedarraylistlegend.push(tempcohort);
																	}															
															}											
																								
														count4++;
													}
																
												count3++;
											}
											
									//alert(combinedarraylist);
									//alert(combinedarraylistlegend);
									
									if (combinedarraylist.length > 2)
										{
												
											var ANOVAanalysis = calculateANOVAwithmaxdifference(combinedarraylist);
											var tempinsert = [ANOVAanalysis[0], ANOVAanalysis[1], ANOVAanalysis[2], temptimepoint, temptreatment, tempparameter, tempgroup];
											finalresultarray.push(tempinsert);
										}

									if (combinedarraylist.length > 1)
										{
											var TTestanalysis = calculateTTestwithmaxdifference(combinedarraylist, combinedarraylistlegend);
											///Returns Array of Arrays -> [[PValue, TScore, combinedarraylistlegend[count2], combinedarraylistlegend[count], difference, targetmean, referencemean]];
											
											var countT = 0;
											while (countT < TTestanalysis.length)
												{
													var individualTTestArray = TTestanalysis[countT];
													individualTTestArray.push(temptimepoint, temptreatment, tempparameter);
													finalresultarrayTTest.push(individualTTestArray);
													///individualTTestArray -> [[PValue, TScore, combinedarraylistlegend[count2], combinedarraylistlegend[count], difference, targetmean, referencemean, temptimepoint, temptreatment, tempparameter]];
													countT++;
												}
										}


																				
									countP++;
								}
								
							count2++;
						}
					count++;
				}			
		}
		
	if (finalresultarray.length > 1)
		{
			finalresultarray.sort(function(a,b){
				return a[0] - b[0];
			});
		}
	else
		{
			var finalresultarray = null;
		}

	if (finalresultarrayTTest.length > 1)
		{
			finalresultarrayTTest.sort(function(a,b){
				return a[0] - b[0];
			});
		}	
	else
		{
			var finalresultarrayTTest = null;
		}	
	
	var botharrays = [finalresultarray, finalresultarrayTTest];
	
	return botharrays;		
}
	
	
	
////Prepare and Run ANOVA Analysis on TREATMENT CLUSTERS/// 
////Prepare and Run ANOVA Analysis on TREATMENT CLUSTERS/// 
function analyzetreatmentsattimepointparameterANOVA(MasterTreatmentCohortArray, timepointlist, treatmentlist, groupslist, groupsparentchildlist, populationlist, outcomeslist, cancertypetreatmentpairlist) {
	
	var concatenatedpopulationoutcomeslist = populationlist.concat(outcomeslist);
	//alert(concatenatedpopulationoutcomeslist);
	
	var finalresultarray = [["P Value", "F Score", "Max Difference", "Timepoint", "Treatment", "Parameter", "Group Parent"]]; 
	var finalresultarrayTTest = [["P Value", "T Score","Target Population", "Reference Population", "Difference", "Target Mean", "Reference Mean", "Timepoint", "Group", "Parameter"]];
	var tempgroup = "ALL";
	
	if (treatmentlist.length > 1)
		{	
					var count = 0;
					while (count < timepointlist.length)
						{
							var temptimepoint = timepointlist[count];
							var temptimepoint = String(temptimepoint);
							
							var count2 = 0; 
							while (count2 < 1)
								{	
									
									var countP = 0;
									while (countP < concatenatedpopulationoutcomeslist.length)
										{
											var tempparameter = concatenatedpopulationoutcomeslist[countP];

											var combinedarraylist = [];
											var combinedarraylistlegend = [];
											
												var count3 = 0;
												while (count3 < treatmentlist.length)
													{	
														var temptreatmentselection = treatmentlist[count3];
														var temptreatmentselection = String(temptreatmentselection);
														
														var count4 = 0;
														while (count4 < MasterTreatmentCohortArray.length)
															{
																var tempheaderrow = MasterTreatmentCohortArray[0];
																var treatmentarraylist = [];
																var temprow = MasterTreatmentCohortArray[count4];
																//alert(temprow[0] + "  " + temptimepoint + "  " + temprow[1] + "  " + temptreatment + "  " + groupcheck);
																
																if (temprow[0] == temptimepoint && temprow[1] == "ALL" && temprow[2] == "ALL")
																	{
																		var count4 = 9999999999;
																		var count5 = 0;
																		while (count5 < tempheaderrow.length)
																			{																																																		
																				var tempselectedheader = tempheaderrow[count5];
																				var tempselectedheader = String(tempselectedheader);
																				var targetheader = "Composite - " + temptreatmentselection + ": " + tempparameter;
																
																				if (targetheader == tempselectedheader)
																					{
																						
																						var tempALLVALUESposition = count5 + 1;
																						var tempALLVALUESdata = temprow[tempALLVALUESposition];
																						if (tempALLVALUESdata.length > 0 && isNaN(tempALLVALUESdata[0]) == false)
																							{
																								var count6 = 0;
																								while (count6 < tempALLVALUESdata.length)
																									{
																										treatmentarraylist.push(tempALLVALUESdata[count6]);
																										count6++;
																									}
																							}
																						var count5 = 9999999;
																					}
																				count5++;
																			}
																		
																	}
																
																if (treatmentarraylist.length > 0)
																	{
																		combinedarraylist.push(treatmentarraylist);
																		combinedarraylistlegend.push(temptreatmentselection);
																	}											
																										
																count4++;
															}
																		
														count3++;																												
													}

											if (combinedarraylist.length > 2)
												{
													var ANOVAanalysis = calculateANOVAwithmaxdifference(combinedarraylist);
													var tempinsert = [ANOVAanalysis[0], ANOVAanalysis[1], ANOVAanalysis[2], temptimepoint, "ALL", tempparameter, "ALL"];
													finalresultarray.push(tempinsert);
												}

											if (combinedarraylist.length > 1)
												{
													var TTestanalysis = calculateTTestwithmaxdifference(combinedarraylist, combinedarraylistlegend);
													///Returns Array of Arrays -> [[PValue, TScore, combinedarraylistlegend[count2], combinedarraylistlegend[count], difference, targetmean, referencemean]];
													
													var countT = 0;
													while (countT < TTestanalysis.length)
														{
															var individualTTestArray = TTestanalysis[countT];
															individualTTestArray.push(temptimepoint, "Total", tempparameter);
															finalresultarrayTTest.push(individualTTestArray);
															///individualTTestArray -> [[PValue, TScore, combinedarraylistlegend[count2], combinedarraylistlegend[count], difference, targetmean, referencemean, temptimepoint, group, tempparameter]];
															countT++;
														}
												}
											countP++;
										}
										
									count2++;
								}
							count++;
						}

		}
			
	if (finalresultarray.length > 1)
		{
			finalresultarray.sort(function(a,b){
				return a[0] - b[0];
			});
		}
	else
		{
			var finalresultarray = null;
		}

	if (finalresultarrayTTest.length > 1)
		{
			finalresultarrayTTest.sort(function(a,b){
				return a[0] - b[0];
			});
		}	
	else
		{
			var finalresultarrayTTest = null;
		}	
	
	var botharrays = [finalresultarray, finalresultarrayTTest];
	return botharrays;
}











/////Functions for parsing data from raw array (newbasearray)///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////Functions for parsing data from raw array (newbasearray)///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////Functions for parsing data from raw array (newbasearray)///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////Functions for parsing data from raw array (newbasearray)///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///Determine Timepoint Postion///
function determinetimepointposition(newbasearray) {
	var count = 0; 
	var timepointposition = -1;
	while (count < newbasearray.length) 
		{
			var checker = newbasearray[0][count];
			if (checker == "Timepoint")
				{
					var timepointposition = count;
					count++;
				}
			else {	count++;}
		}
	if (timepointposition < 0)
		{
			alert("Timepoint Position Not Found");
		}
	return timepointposition;
}

///Create Sorted Timepoint List with Experimental vs Baseline Differentials///
function createsortedtimepointlistwithdifferentials(newbasearray, timepointposition) {
	
	var timepointlist = [];
	var count = 1;
	while (count < newbasearray.length)
		{
			var checker = newbasearray[count][timepointposition];
			var checker = Number(checker);
			var ValueInIndex = timepointlist.indexOf(checker);
			if (ValueInIndex < 0 )
				{
					timepointlist.push(checker);
				}
			count++;
		}
	timepointlist.sort(function(a, b){return a-b});

	/////Create Differential TimepointList (Experimental Timepoint vs Baseline)
	var tempcomparisonlist = [];
	if (timepointlist[0] == 0 && timepointlist.length > 1)
		{
			var count = 1;
			while (count < timepointlist.length)
				{
					var temptimepointcomparison = timepointlist[count] + " vs " + 0;
					tempcomparisonlist.push(temptimepointcomparison);
					count++;
				}
		}

	if (tempcomparisonlist.length > 0)
		{
			var count = 0;
			while (count < tempcomparisonlist.length)
				{		
					var tempcomparisoninsert = tempcomparisonlist[count];
					timepointlist.push(tempcomparisoninsert);
					count++;
				}
		}
	
	return timepointlist;
}

///Determine Patient Position///
function determinepatientposition(newbasearray) {
	var count = 0; 
	var patientposition = -1;
	while (count < newbasearray[0].length) 
		{
			var checker = newbasearray[0][count];
			if (checker == "PatientID")
				{
					var patientposition = count;
				}
			count++;
		}
	if (patientposition < 0)
		{
			alert("Patient Position Not Found");
		}
		
	return patientposition;
}

///Create Sorted Patient List///
function createsortedpatientlist(newbasearray, patientposition) {
	var patientlist = [];
	var count = 1;
	while (count < newbasearray.length)
		{
			var checker = newbasearray[count][patientposition];
			var ValueInIndex = patientlist.indexOf(checker);
			if (ValueInIndex < 0 && checker.length > 0 && checker !== null && checker !== "null")
				{
					patientlist.push(checker);
				}
			count++;
		}
	patientlist.sort();
	
	return patientlist;
}


////Create Sorted Population List Array/////
function createsortedpopulationlistarray(newbasearray) {
	var populationlist = [];
	var populationlistindex = [];
	var sortedpopulationlistarray = [];
	
	var count = 0;
	while (count < newbasearray[0].length)
		{
			var checker = newbasearray[0][count];
			
			var n = checker.indexOf(":");
			
			if (n > -1)
				{
					var CheckForNonNullValues = -1;
					var count2 = 1;
					while (count2 < newbasearray.length)
						{
							if (newbasearray[count2][count].length > 0 && newbasearray[count2][count] !== "null" && newbasearray[count2][count] !== null)
								{
									CheckForNonNullValues++;
								}
							count2++;
						}
						
					if (CheckForNonNullValues > 0)
						{	
							var selectedpopulation = checker;
							var selectedpopulation = selectedpopulation + ".";
							var ValueInIndex = populationlist.indexOf(selectedpopulation);
							if (ValueInIndex < 0)
								{
									populationlist.push(selectedpopulation);
									populationlistindex.push(count);
									sortedpopulationlistarray.push([selectedpopulation, count]);
								}
						}
				}
			count++;
		}
	
	sortedpopulationlistarray.sort();
	
	var populationlist = [];
	var populationlistindex = [];
	
	var count = 0;
	while (count < sortedpopulationlistarray.length)
		{
			populationlist.push(sortedpopulationlistarray[count][0]);
			populationlistindex.push(sortedpopulationlistarray[count][1]);
			count++;
		}
	var allthreepopulationarrays = [populationlist, populationlistindex, sortedpopulationlistarray]
	
	return allthreepopulationarrays;
}
	

///Create Sorted Outcomes List///
function createsortedoutcomeslistarray(newbasearray) {
	var outcomeslist = [];
	var outcomeslistindex = [];
	var sortedoutcomeslist = [];

	var count = 0;
	while (count < newbasearray[0].length)
		{
			var checker = newbasearray[0][count].indexOf("Outcomes -");
			if (checker > -1)
				{
					var CheckForNonNullValues = -1;
					var UniqueValuesList = [];
					var UniqueValuesCount = 0;
					var count2 = 1;
					while (count2 < newbasearray.length)
						{
							if (newbasearray[count2][count].length > 0 && newbasearray[count2][count] !== "null" && newbasearray[count2][count] !== null)
								{
									CheckForNonNullValues++;
									var tempvalue = newbasearray[count2][count];
									var checkforuniquevalue = UniqueValuesList.indexOf(tempvalue);
									if (checkforuniquevalue < 0)
										{
											UniqueValuesList.push(tempvalue);
											UniqueValuesCount++;
										}
								}
							count2++;
						}				
					
					if (CheckForNonNullValues > 1 && UniqueValuesCount > 1)
						{				
							var selectedmarker = newbasearray[0][count];
							var ValueInIndex = outcomeslist.indexOf(selectedmarker);
							if (ValueInIndex < 0 )
								{
									outcomeslist.push(selectedmarker);
									outcomeslistindex.push(count);
									sortedoutcomeslist.push([selectedmarker, count]);
								}
						}
				}
			count++;
		}
		
	sortedoutcomeslist.sort();
	var allthreeoutcomesarrays = [outcomeslist, outcomeslistindex, sortedoutcomeslist];
	
	return allthreeoutcomesarrays;
}


///Create Sorted Groups List///
function createsortedgroupslistarray(newbasearray) {

	var groupslist = [];
	var groupslistindex = [];
	var sortedgroupslist = [];
	var groupchildlist = [];
	var groupparentchildlist = [];
	
	var count = 0;
	while (count < newbasearray[0].length)
		{
			var checker = newbasearray[0][count].indexOf("Group -");
			if (checker > -1)
				{
					var CheckForNonNullValues = 0;
					var count2 = 1;
					var tempchildlist = [];
					var tempparentchildlist = [];
					while (count2 < newbasearray.length)
						{
							if (newbasearray[count2][count].length > 0 && newbasearray[count2][count] !== "null" && newbasearray[count2][count] !== null)
								{
									CheckForNonNullValues++;
									
									var tempchildvalue = newbasearray[count2][count];
									if (tempchildlist.indexOf(tempchildvalue) == -1)
										{
											tempchildlist.push(tempchildvalue);	
										}
								}
							count2++;
						}	


					if (CheckForNonNullValues > 5)
						{	
							var selectedmarker = newbasearray[0][count];
							var ValueInIndex = groupslist.indexOf(selectedmarker);
							if (ValueInIndex < 0 )
								{
									groupslist.push(selectedmarker);
									groupslistindex.push(count);
									sortedgroupslist.push([selectedmarker, count]);
									groupchildlist.push(tempchildlist);
									
									var count6 = 0;
									while (count6 < tempchildlist.length)
										{
											var tempchildvalue2 = tempchildlist[count6];
											var tempparentchildvalue = newbasearray[0][count] + ": " + tempchildvalue2;
											groupparentchildlist.push(tempparentchildvalue);
											count6++;
										}
											
								}
						}
				}
			count++;
		}
	
	
	sortedgroupslist.sort();
	var allgroupsarrays = [groupslist, groupslistindex, sortedgroupslist, groupparentchildlist];
	
	return allgroupsarrays;
}



///Determine CancerType Position////
function determinecancertypeposition(newbasearray) {
	var count = 0; 
	var cancertypeposition = -1;
	while (count < newbasearray[0].length) 
		{
			var checker = newbasearray[0][count];
			if (checker == "CancerType")
				{
					var cancertypeposition = count;
				}
			count++;
		}
	if (cancertypeposition < 0)
		{
			alert("Cancer Type Position Not Found");
		}
	
	return cancertypeposition;
}


///Create Sorted Cancer Type List///
function createsortedcancertypelist(newbasearray, cancertypeposition) {
	var cancertypelist = [];
	var count = 1;
	while (count < newbasearray.length)
		{
			var checker = newbasearray[count][cancertypeposition];
			var ValueInIndex = cancertypelist.indexOf(checker);
			if (ValueInIndex < 0 )
				{
					cancertypelist.push(checker);
				}
			count++;
		}
	cancertypelist.sort();
	
	return cancertypelist;
}


///Determine Treatment Position///
function determinetreatmentposition(newbasearray) {
	var count = 0; 
	var treatmentposition = -1;
	while (count < newbasearray[0].length) 
		{
			var checker = newbasearray[0][count];
			if (checker == "Treatment")
				{
					var treatmentposition = count;
				}
			count++;
		}
	if (treatmentposition < 0)
		{
			alert("Treatment Position Not Found");
		}
	
	return treatmentposition;
}

///Create Sorted List of Treatments///
function createsortedtreatmentlist(newbasearray, treatmentposition) {
	var treatmentlist = [];
	var count = 1;
	while (count < newbasearray.length)
		{
			var checker = newbasearray[count][treatmentposition];
			var ValueInIndex = treatmentlist.indexOf(checker);
			if (ValueInIndex < 0 )
				{
					treatmentlist.push(checker);
				}
			count++;
		}
	
	treatmentlist.sort();
	
	return treatmentlist;
}


///Create CancerType-Treatment Pair List (Cohorts)///
function createcancertypetreatmentpairlist(newbasearray, cancertypeposition, treatmentposition) { 
	var cancertypetreatmentpairlist = [];
	var count = 1;
	while (count < newbasearray.length)
		{
			var checker1 = newbasearray[count][cancertypeposition];
			var checker2 = newbasearray[count][treatmentposition];
			var mergedcancertypetreatmentpair = checker1 + " - " + checker2;
			var ValueInIndex = cancertypetreatmentpairlist.indexOf(mergedcancertypetreatmentpair);
			if (ValueInIndex < 0 )
				{
					cancertypetreatmentpairlist.push(mergedcancertypetreatmentpair);
				}
			count++;
		}
	
	cancertypetreatmentpairlist.sort();
	
	return cancertypetreatmentpairlist;
}


///Create Timepoint-Parameter Pairs List///
function createtimepointparameterpairslist(timepointlist, populationlist) { 
	var timepointparameterpairslist = [];
	var populationlistcount = 0;
	while (populationlistcount < populationlist.length)
		{
			var selectedpopulation = populationlist[populationlistcount];
			var timepointlistcount = 0;
			while (timepointlistcount < timepointlist.length)
				{
					var selectedtimepoint = timepointlist[timepointlistcount];
					var HeaderToInsert = selectedtimepoint + ": " + selectedpopulation;
					timepointparameterpairslist.push(HeaderToInsert);
					timepointlistcount++;
				}
			populationlistcount++;
		}
	
	return timepointparameterpairslist;
}
	

//////Create Stable Duplicate of an Array
function createstableduplicatearray(array) {
	var duplicatearray = [];
	var count = 0;
	while (count < array.length)
		{
			duplicatearray.push(array[count]);
			count++;
		}
	return duplicatearray;
}


///////Construct List of Cohort-Outcome/Population Pairs Array Headers (Timepoint-Parameter) List///////////
///////Construct List of Cohort-Outcome/Population Pairs Array Headers (Timepoint-Parameter) List///////////
function createcohortpopulationoutcomepairlist(cancertypetreatmentpairlist, outcomeslist, populationlist, treatmentlist) {
	
	var cohortpopulationoutcomepairs = [];
	var count1 = 0;
	while (count1 < populationlist.length)
		{
			var count2 = 0;
			while (count2 < cancertypetreatmentpairlist.length)
				{
					var tempvalue = cancertypetreatmentpairlist[count2] + ": " + populationlist[count1];
					cohortpopulationoutcomepairs.push(tempvalue);
					count2++;
				}
			
			var count3 = 0;
			while (count3 < treatmentlist.length)
				{
					var tempvalue = "Composite - " + treatmentlist[count3] + ": " + populationlist[count1];
					cohortpopulationoutcomepairs.push(tempvalue);
					count3++;
				}
				
			count1++;
		}
		
	while (count1 < outcomeslist.length)
		{
			var count2 = 0;
			while (count2 < cancertypetreatmentpairlist.length)
				{
					var tempvalue = cancertypetreatmentpairlist[count2] + ": " + outcomeslist[count1];
					cohortpopulationoutcomepairs.push(tempvalue);
					count2++;
				}

			var count3 = 0;
			while (count3 < treatmentlist.length)
				{
					var tempvalue = "Composite - " + treatmentlist[count3] + ": " + outcomeslist[count1];
					cohortpopulationoutcomepairs.push(tempvalue);
					count3++;
				}

			count1++;
		}		
	
	return cohortpopulationoutcomepairs;
}




/////////////Create Composite Treatment-Population/Outcomes List for COLUMN CHART/////
/////////////Create Composite Treatment-Population/Outcomes List for COLUMN CHART/////
function createcompositetreatmentpopulationoutcomeslistforCOLUMNCHART(treatmentlist, populationlist, outcomeslist) {
	var compositetreatmentpopulationlist = [];
	var count = 0;
	while (count < treatmentlist.length)
		{
			var temptreatment = treatmentlist[count];
			
			var count2 = 0;
			while (count2 < populationlist.length)
				{
					var temppopulation = populationlist[count2];
					var tempcomposite = "Composite - " + temptreatment + ": " + temppopulation;
					compositetreatmentpopulationlist.push(tempcomposite);
					count2++;
				}

			var count2 = 0;
			while (count2 < outcomeslist.length)
				{
					var tempoutcome = outcomeslist[count2];
					var tempcomposite = "Composite - " + temptreatment + ": " + tempoutcome;
					compositetreatmentpopulationlist.push(tempcomposite);
					count2++;
				}

			count++;
		}
	//alert(compositetreatmentpopulationlist);
	return compositetreatmentpopulationlist;
}


/////Create Appended (CancerType and Composite) Treatment Pair List//////////
/////Create Appended (CancerType and Composite) Treatment Pair List//////////
function createappendedcancertypewithcompositetreatmentpairlist(cancertypetreatmentpairlist, treatmentlist) {
	var appendedcancertypetreatmentpairlist = [];
	var count = 0;
	while (count < cancertypetreatmentpairlist.length)
		{
			appendedcancertypetreatmentpairlist.push(cancertypetreatmentpairlist[count]);
			count++;
		}
	var count = 0;
	while (count < treatmentlist.length)
		{
			appendedcancertypetreatmentpairlist.push("Composite - " + treatmentlist[count]);
			count++;
		}	
		
	//alert(appendedcancertypetreatmentpairlist);
	return appendedcancertypetreatmentpairlist;
}








































































////////////Functions for Constructing Master Outcomes Array (Outcomes Analysis)/////////////////////////////////////////////
////////////Functions for Constructing Master Outcomes Array (Outcomes Analysis)/////////////////////////////////////////////
////////////Functions for Constructing Master Outcomes Array (Outcomes Analysis)/////////////////////////////////////////////
////////////Functions for Constructing Master Outcomes Array (Outcomes Analysis)/////////////////////////////////////////////
////////////Functions for Constructing Master Outcomes Array (Outcomes Analysis)/////////////////////////////////////////////
////////////Functions for Constructing Master Outcomes Array (Outcomes Analysis)/////////////////////////////////////////////

/////Construct Outcomes Array Headers/////
function constructoutcomesarrayheaders(outcomeslist, groupslist, timepointparameterpairslist) {
	var outcomesarrayheaders = [];
	outcomesarrayheaders.push("PatientID");
	outcomesarrayheaders.push("CancerType");
	outcomesarrayheaders.push("Treatment");
	outcomesarrayheaders.push("CancerTreatPair");
	outcomesarrayheaders.push("Style1");
	outcomesarrayheaders.push("Style2");	
	
	var count = 0;
	while (count < outcomeslist.length)
		{
			var tempvalue = outcomeslist[count];
			outcomesarrayheaders.push(tempvalue);
			count++;
		}

	var count = 0;
	while (count < groupslist.length)
		{
			var tempvalue = groupslist[count];
			outcomesarrayheaders.push(tempvalue);
			count++;
		}

	var count = 0;
	while (count < timepointparameterpairslist.length)
		{
			var tempvalue = timepointparameterpairslist[count];
			outcomesarrayheaders.push(tempvalue);
			count++;
		}

	return outcomesarrayheaders;
}


////Determine CancerType-Treatment Pair Position
function determinecancertypetreatmentpairposition(MasterOutcomesArray) {
	var count = 0;
	while (count < MasterOutcomesArray[0].length)
		{
			if (MasterOutcomesArray[0][count] == "CancerTreatPair")
				{
					var position = count;
					count = 999999999999999999999;
				}
			count++;
		}
	
	return position;
}

////Determine Style Position 1
function determinestyleposition1(MasterOutcomesArray) {
	var count = 0;
	while (count < MasterOutcomesArray[0].length)
		{
			if (MasterOutcomesArray[0][count] == "Style1")
				{
					var position = count;
					count = 999999999999999999999;
				}
			count++;
		}
	
	return position;
}

////Determine Style Position 2
function determinestyleposition2(MasterOutcomesArray) {
	var count = 0;
	while (count < MasterOutcomesArray[0].length)
		{
			if (MasterOutcomesArray[0][count] == "Style2")
				{
					var position = count;
					count = 999999999999999999999;
				}
			count++;
		}
	
	return position;
}




////Determine Initial Outcome Position in Array////
function determinefirstoutcomeposition(MasterOutcomesArray) {
	var headerloopcount = 0;
	var outcomesindexcheck = -1;
	while (headerloopcount < MasterOutcomesArray[0].length)
				{
					var selectedheadervalue = MasterOutcomesArray[0][headerloopcount];
					var outcomesindexcheck = selectedheadervalue.indexOf("Outcomes");
						
					if (outcomesindexcheck > -1)
						{
							var firstoutcomeposition = headerloopcount;
							headerloopcount = 9999999999999999999999;
						}
					headerloopcount++;
				}
	return firstoutcomeposition;
}


////Determine Initial Population Position in Array///
function determinefirstpopulationposition(MasterOutcomesArray) {
	var headerloopcount = 0;
	var populationindexcheck = -1;
	while (headerloopcount < MasterOutcomesArray[0].length)
				{
					var selectedheadervalue = MasterOutcomesArray[0][headerloopcount];
					var populationindexcheck = selectedheadervalue.indexOf(":");
						
					if (populationindexcheck > -1)
						{
							var firstpopulationposition = headerloopcount;
							headerloopcount = 9999999999999999999999;
						}
					headerloopcount++;
				}
			return firstpopulationposition;
}


////////CancerType-Treatment Pair Row Array///////////
function createcancertypetreatpairrowsarray(MasterOutcomesArray, cancertypetreatmentpairlist, cancertreatpairposition) {

	var cancertypetreatpairrowsarray = [];
	var count = 0;
	while (count < cancertypetreatmentpairlist.length)
		{
			
			var selectedpair = cancertypetreatmentpairlist[count];
			var adjustedrowlist = [];
			var unadjustedrowlist = [];
			
			var count2 = 0;
			while (count2 < MasterOutcomesArray.length)
				{
					
					var masterarrayselection = MasterOutcomesArray[count2][cancertreatpairposition];
					if (masterarrayselection == selectedpair)
						{
							adjustedrowlist.push((count2 - 1));
							unadjustedrowlist.push((count2));
						}
					count2++;
				}
				
			var mergedinsert = [selectedpair,adjustedrowlist,unadjustedrowlist];
			cancertypetreatpairrowsarray.push(mergedinsert);
			count++;
		}
		
	return cancertypetreatpairrowsarray;
}


////////Groups Parent-Child Selection Construction and Rows Array///////////
function creategroupsparentchildselectionandrowsarray(MasterOutcomesArray) {

	var groupsubsetuniquelist = [];
	var groupsubsetrowarray = [];
	var unadjustedgroupsubsetrowarray = [];

	var headerloopcount = 0;
	while (headerloopcount < MasterOutcomesArray[0].length)
		{
			var groupsindexcheck = -1;
			var selectedheadervalue = MasterOutcomesArray[0][headerloopcount];
			var groupsindexcheck = selectedheadervalue.indexOf("Group -");
			
			if (groupsindexcheck > -1)
				{	
					var selectedgroup = selectedheadervalue;
					var selectedgroupposition = headerloopcount;
							
					var masterloopcount = 1;
					while (masterloopcount < MasterOutcomesArray.length)
						{
							var selectedgroupsubsetvalue = MasterOutcomesArray[masterloopcount][selectedgroupposition];																			
							var groupparentchildpair = selectedgroup + ": " + selectedgroupsubsetvalue;	
		
							var groupparentchildpairuniquecheck = groupsubsetuniquelist.indexOf(groupparentchildpair);
							if (groupparentchildpairuniquecheck < 0)
								{
									groupsubsetuniquelist.push(groupparentchildpair);
									var freshrowarray = [];
									groupsubsetrowarray.push(freshrowarray);
								}								
							///Assign Row Values to groupparentchildpair
							var arraypositionofselection = groupsubsetuniquelist.indexOf(groupparentchildpair);
							groupsubsetrowarray[arraypositionofselection].push(masterloopcount);	
							masterloopcount++;
						}
				}
			headerloopcount++;
		}
	
	var AllArrays = [groupsubsetuniquelist, groupsubsetrowarray, unadjustedgroupsubsetrowarray];
	return AllArrays;
	
}


//////Construct Single Array with Group-Subset Pairs and Row Arrays/////
function createmergedgroupsubsetpairnamesandrowsarray(groupsubsetuniquelist, groupsubsetrowarray) {

	var mergedgroupsubsetpairnamesandrows = [];
	var count = 0;
	while (count < groupsubsetuniquelist.length)
		{
			var tempgroupsubsetpair = groupsubsetuniquelist[count];
			var tempgroupsubsetpairrowsarray = groupsubsetrowarray[count];
			mergedgroupsubsetpairnamesandrows.push([tempgroupsubsetpair,tempgroupsubsetpairrowsarray]);
			count++;
		}
	
	return mergedgroupsubsetpairnamesandrows;
}

////////Construct Single Array with Cohort-Group Pairs and Row Arrays//////
function createmergedcohortgrouppairsandrowsarray(cancertypetreatpairrowsarray, mergedgroupsubsetpairnamesandrows) {

	var cohortgrouppairsandrows = [];
	var count = 0;
	while (count < cancertypetreatpairrowsarray.length)
		{
			var tempcohortname = cancertypetreatpairrowsarray[count][0];
			var tempcohortrows = cancertypetreatpairrowsarray[count][2];
			
			var count2 = 0;
			while (count2 < mergedgroupsubsetpairnamesandrows.length)
				{
					var tempgroupname = mergedgroupsubsetpairnamesandrows[count2][0];
					var tempgrouprows = mergedgroupsubsetpairnamesandrows[count2][1];
					
					var tempmergedrows = [];
					var count3 = 0;
					while (count3 < tempcohortrows.length)
						{
							var rowtocheck = tempcohortrows[count3];
							var uniquechecker = tempgrouprows.indexOf(rowtocheck);
							if (uniquechecker > -1)
								{
									tempmergedrows.push(rowtocheck);
								}
							count3++;
						}
					
					if (tempmergedrows.length > 4)
						{
							cohortgrouppairsandrows.push([tempcohortname,tempgroupname,tempmergedrows]);
						}
					count2++;
				}
			count++;
		}
	
	return cohortgrouppairsandrows;
}


/////Create Simple Treatment Colors List for Outcomes Array/////
/////Create Simple Treatment Colors List for Outcomes Array/////
function createsimpletreatmentcolorslist(cancertypetreatmentpairlist, treatmentcolorsarray, treatmentlist, cancertypeshapesarrayhtmlcodes, cancertypelist, cancertypecolorsarray) {
	var SimpleCohortColorsArray = [];
	
	var count = 0;
	while (count < cancertypetreatmentpairlist.length)
		{
			var selectedpair = cancertypetreatmentpairlist[count];
			var positionofspacer = selectedpair.indexOf(" - ");
			var selectedcancertype = selectedpair.substring(0,positionofspacer);
			var positionofselectedcancertype = cancertypelist.indexOf(selectedcancertype);
			if (positionofselectedcancertype < 0)
				{
					positionofselectedcancertype = cancertypelist.length;
				}
			var selectedtreatment = selectedpair.substring((positionofspacer + 3),selectedpair.length);
			var positionofselectedtreatment = treatmentlist.indexOf(selectedtreatment);
			var correspondingcolor = treatmentcolorsarray[positionofselectedtreatment];
			var shapeplaceholder = cancertypeshapesarrayhtmlcodes[positionofselectedcancertype];
			var cancertypecolor = cancertypecolorsarray[positionofselectedcancertype];
			if (selectedcancertype == "Composite")
				{
					var cancertypecolor = "Black";
				}
			SimpleCohortColorsArray.push([selectedpair, shapeplaceholder, correspondingcolor, cancertypecolor]);
			count++;
		}
	
	return SimpleCohortColorsArray;
}




///////Create Master Outcomes Array/////
///////Create Master Outcomes Array/////
///////Create Master Outcomes Array/////
function createMasterOutcomesArray(newbasearray, cancertypeshapesarray, cancertypeshapesarrayhtmlcodes, treatmentcolorsarray, cancertreatpairsselectionformat, timepointposition, timepointlist, patientposition, patientlist, populationlist, populationlistindex, outcomeslist, outcomeslistindex, groupslist, groupslistindex, cancertypeposition, cancertypelist, treatmentposition, treatmentlist, cancertypetreatmentpairlist, timepointparameterpairslist, outcomesarrayheaders) {
		var MasterOutcomesArray = [];
		var AllRowsArray = [];
		MasterOutcomesArray.push(outcomesarrayheaders);

	////Loop through unique patient list
		var patientcount = 0;
		while (patientcount < patientlist.length)
			{
				var outcomesarraydatarow = [];
				var selectedpatient = patientlist[patientcount];
				outcomesarraydatarow.push(selectedpatient);
			
			////Loop through Outcomes Array Headers
				var headerloopcount = 0;
				while (headerloopcount < MasterOutcomesArray[0].length)
					{
						///Define the Selected Column Header
						var selectedheadervalue = MasterOutcomesArray[0][headerloopcount];
						var outcomesindexcheck = -1;
						var populationindexcheck = -1;
						var groupsindexcheck = -1;
						var cancertypecheck = -1;
						var treatmentcheck = -1;
						var cancertreatpaircheck = -1;
						var stylecheck1 = -1;
						var stylecheck2 = -1;
						var comparisontimepointcheck = -1;
						
						var outcomesindexcheck = selectedheadervalue.indexOf("Outcomes");
						var populationindexcheck = selectedheadervalue.indexOf(":");
						var groupsindexcheck = selectedheadervalue.indexOf("Group -");
						var cancertypecheck = selectedheadervalue.indexOf("CancerType");
						var treatmentcheck = selectedheadervalue.indexOf("Treatment");
						var cancertreatpaircheck = selectedheadervalue.indexOf("CancerTreatPair");
						var stylecheck1 = selectedheadervalue.indexOf("Style1");
						var stylecheck2 = selectedheadervalue.indexOf("Style2");
						var comparisontimepointcheck = selectedheadervalue.indexOf(" vs ");
						
						///Actions For Each Header Type	
						if (outcomesindexcheck > -1)
							{	
								var selectedoutcome = MasterOutcomesArray[0][headerloopcount];
								var selectedoutcomeposition1 = outcomeslist.indexOf(selectedoutcome);
								var selectedoutcomeposition2 = outcomeslistindex[selectedoutcomeposition1];
								
								///Loop Through newbasearray to Find Rows With Both Selected Patient and Selected Outcome
								var masterloopcount = 0;
								var selectedoutcomevalue = null;
								while (masterloopcount < newbasearray.length)
									{
										if (newbasearray[masterloopcount][patientposition] == selectedpatient)
											{
												var selectedoutcomevalue = newbasearray[masterloopcount][selectedoutcomeposition2];
												var placeholderoutcomesposition = masterloopcount;
												var masterloopcount = 999999999999999999;
											}
										masterloopcount++;
									}
								if (selectedoutcomevalue == "null" || selectedoutcomevalue == null || selectedoutcomevalue == "" || selectedoutcomevalue == "NULL")
									{
										if (selectedoutcomevalue !== 0)
											{
												var selectedoutcomevalue = null;
											}
										else {selectedoutcomevalue = 0;}
									}
								else
									{
										var selectedoutcomevalue = Number(selectedoutcomevalue);
									}
								outcomesarraydatarow.push(selectedoutcomevalue);
							}

						if (groupsindexcheck > -1)
							{	
								var selectedgroup = MasterOutcomesArray[0][headerloopcount];
								var selectedgroupposition1 = groupslist.indexOf(selectedgroup);
								var selectedgroupposition2 = groupslistindex[selectedgroupposition1];
								
								var masterloopcount = 0;
								var selectedgroupvalue = null;
								while (masterloopcount < newbasearray.length)
									{
										if (newbasearray[masterloopcount][patientposition] == selectedpatient)
											{
												var selectedgroupvalue = newbasearray[masterloopcount][selectedgroupposition2];									
												var masterloopcount = 999999999999999999;
											}
										masterloopcount++;
									}
								
								if (selectedgroupvalue == "null" || selectedgroupvalue == null || selectedgroupvalue == "" || selectedgroupvalue == "NULL")
									{
										if (selectedgroupvalue !== 0)
											{
												var selectedgroupvalue = "Undefined";
											}
									}
								
								var selectedgroupvaluetype = typeof selectedgroupvalue;
								if (selectedgroupvaluetype == "number")
									{
										var selectedgroupvalue = selectedgroupvalue.toString();
									}
								
								outcomesarraydatarow.push(selectedgroupvalue);
							}

		///Single Timepoint Values				
						if (populationindexcheck > -1 && comparisontimepointcheck == -1)
							{
								var selectedvaluepair = outcomesarrayheaders[headerloopcount];
								var colonposition = selectedvaluepair.indexOf(":");
								var selectedtimepoint1 = selectedvaluepair.substring(0, colonposition);
								var selectedpopulation1 = selectedvaluepair.substring((colonposition + 2), selectedvaluepair.length);
								var selectedpopulationposition1 = populationlist.indexOf(selectedpopulation1);
								var selectedpopulationposition2 = populationlistindex[selectedpopulationposition1];
								
								var masterloopcount = 0;
								var selectedpopulationvalue = null;
								while (masterloopcount < newbasearray.length)
									{
										if (newbasearray[masterloopcount][patientposition] == selectedpatient && newbasearray[masterloopcount][timepointposition] == selectedtimepoint1)
											{
												var selectedpopulationvalue = newbasearray[masterloopcount][selectedpopulationposition2];
												var placeholderpopulationposition = masterloopcount;
												var masterloopcount = 999999999999999999;
											}
										masterloopcount++;
									}
								
								if (selectedpopulationvalue == "null" || selectedpopulationvalue == null  || selectedpopulationvalue == ""  || selectedpopulationvalue == "NULL")
									{
										if (selectedpopulationvalue !== 0)
											{
												var selectedpopulationvalue = null;
											}
										else {selectedpopulationvalue = 0;}
									}
								else
									{
										var selectedpopulationvalue = Number(selectedpopulationvalue);
									}						
								outcomesarraydatarow.push(selectedpopulationvalue);
							}

		/////////Comparative Timepoint Values				
						if (populationindexcheck > -1 && comparisontimepointcheck > -1)
							{
								var selectedvaluepair = outcomesarrayheaders[headerloopcount];
								var colonposition = selectedvaluepair.indexOf(":");
								var selectedtimepoint1 = selectedvaluepair.substring(0, colonposition);
								var vsposition = comparisontimepointcheck;
								var firsttimepoint = selectedtimepoint1.substring(0, vsposition);
								var secondtimepoint = selectedtimepoint1.substring((vsposition + 4), selectedtimepoint1.length);
								var selectedpopulation1 = selectedvaluepair.substring((colonposition + 2), selectedvaluepair.length);
								var selectedpopulationposition1 = populationlist.indexOf(selectedpopulation1);
								var selectedpopulationposition2 = populationlistindex[selectedpopulationposition1];
								
								////Define Reference (Baseline) Parameter Value
								var masterloopcount = 0;
								var selectedpopulationvalueREFERENCE = null;
								while (masterloopcount < newbasearray.length)
									{
										if (newbasearray[masterloopcount][patientposition] == selectedpatient && newbasearray[masterloopcount][timepointposition] == secondtimepoint)
											{
												var selectedpopulationvalueREFERENCE = newbasearray[masterloopcount][selectedpopulationposition2];
												var placeholderpopulationpositionREFERENCE = masterloopcount;
												var masterloopcount = 999999999999999999;
											}
										masterloopcount++;
									}
								
								if (selectedpopulationvalueREFERENCE == "null" || selectedpopulationvalueREFERENCE == null  || selectedpopulationvalueREFERENCE == ""  || selectedpopulationvalueREFERENCE == "NULL")
									{
										if (selectedpopulationvalueREFERENCE !== 0)
											{
												var selectedpopulationvalueREFERENCE = null;
											}
										else {selectedpopulationvalueREFERENCE = 0;}
									}
								else
									{
										var selectedpopulationvalueREFERENCE = Number(selectedpopulationvalueREFERENCE);
									}	

								////Define Target (Experimental) Parameter Value
								var masterloopcount = 0;
								var selectedpopulationvalueTARGET = null;
								while (masterloopcount < newbasearray.length)
									{
										if (newbasearray[masterloopcount][patientposition] == selectedpatient && newbasearray[masterloopcount][timepointposition] == firsttimepoint)
											{
												var selectedpopulationvalueTARGET = newbasearray[masterloopcount][selectedpopulationposition2];
												var placeholderpopulationpositionTARGET = masterloopcount;
												var masterloopcount = 999999999999999999;
											}
										masterloopcount++;
									}
								
								if (selectedpopulationvalueTARGET == "null" || selectedpopulationvalueTARGET == null  || selectedpopulationvalueTARGET == ""  || selectedpopulationvalueTARGET == "NULL")
									{
										if (selectedpopulationvalueTARGET !== 0)
											{
												var selectedpopulationvalueTARGET = null;
											}
										else {selectedpopulationvalueTARGET = 0;}
									}
								else
									{
										var selectedpopulationvalueTARGET = Number(selectedpopulationvalueTARGET);
									}	

								if (selectedpopulationvalueTARGET > -999999999 && selectedpopulationvalueTARGET !== null && selectedpopulationvalueREFERENCE > -99999999 && selectedpopulationvalueREFERENCE !== null)
									{
										var selectedpopulationvalueRESOLVED = selectedpopulationvalueTARGET - selectedpopulationvalueREFERENCE;
									}
								else
									{
										var selectedpopulationvalueRESOLVED = null;
									}
							
								outcomesarraydatarow.push(selectedpopulationvalueRESOLVED);
							}

					////Process Cancer Type	
						if (cancertypecheck > -1)
							{		
								var masterloopcount = 0;
								var selectedpopulationvalue = null;
								while (masterloopcount < newbasearray.length)
									{
										if (newbasearray[masterloopcount][patientposition] == selectedpatient)
											{
												var selectedpopulationvalue = newbasearray[masterloopcount][cancertypeposition];
												var masterloopcount = 999999999999999999;
											}
										masterloopcount++;
									}

								if (selectedpopulationvalue == "null" || selectedpopulationvalue == null || selectedpopulationvalue == "" || selectedpopulationvalue == "NULL")
									{
										if (selectedpopulationvalue !== 0)
											{
												var selectedpopulationvalue = "Undefined";
											}
									}
								
								var selectedpopulationvaluetype = typeof selectedpopulationvalue;
								if (selectedpopulationvaluetype !== "string")
									{
										var selectedpopulationvalue = selectedpopulationvalue.toString();
									}				
								
								outcomesarraydatarow.push(selectedpopulationvalue);
							}				

					///Process Treatment Type
						if (treatmentcheck > -1)
							{		
								var masterloopcount = 0;
								var selectedpopulationvalue = null;
								while (masterloopcount < newbasearray.length)
									{
										if (newbasearray[masterloopcount][patientposition] == selectedpatient)
											{
												var selectedpopulationvalue = newbasearray[masterloopcount][treatmentposition];
												var masterloopcount = 999999999999999999;
											}
										masterloopcount++;
									}
								
								if (selectedpopulationvalue == "null" || selectedpopulationvalue == null || selectedpopulationvalue == "" || selectedpopulationvalue == "NULL")
									{
										if (selectedpopulationvalue !== 0)
											{
												var selectedpopulationvalue = "Undefined";
											}
									}
								
								var selectedpopulationvaluetype = typeof selectedpopulationvalue;
								if (selectedpopulationvaluetype !== "string")
									{
										var selectedpopulationvalue = selectedpopulationvalue.toString();
									}									
								
								outcomesarraydatarow.push(selectedpopulationvalue);
							}					

						if (cancertreatpaircheck > -1)
							{		
								var cancertreatpairposition = headerloopcount;
								var masterloopcount = 0;
								var selectedpopulationvalue = null;
								while (masterloopcount < newbasearray.length)
									{
										if (newbasearray[masterloopcount][patientposition] == selectedpatient)
											{
												var selectedpopulationvalue1 = newbasearray[masterloopcount][cancertypeposition];								
													if (selectedpopulationvalue1 == "null" || selectedpopulationvalue1 == null || selectedpopulationvalue1 == "" || selectedpopulationvalue1 == "NULL")
														{
															if (selectedpopulationvalue1 !== 0)
																{
																	var selectedpopulationvalue1 = "Undefined";
																}
														}
													
													var selectedpopulationvalue1type = typeof selectedpopulationvalue1;
													if (selectedpopulationvalue1type !== "string")
														{
															var selectedpopulationvalue1 = selectedpopulationvalue1.toString();
														}													
														
												
												var selectedpopulationvalue2 = newbasearray[masterloopcount][treatmentposition];
													if (selectedpopulationvalue2 == "null" || selectedpopulationvalue2 == null || selectedpopulationvalue2 == "" || selectedpopulationvalue2 == "NULL")
														{
															if (selectedpopulationvalue2 !== 0)
																{
																	var selectedpopulationvalue2 = "Undefined";
																}
														}
													
													var selectedpopulationvalue2type = typeof selectedpopulationvalue2;
													if (selectedpopulationvalue2type !== "string")
														{
															var selectedpopulationvalue2 = selectedpopulationvalue2.toString();
														}	


												var mergedcancertypetreatmentpair = selectedpopulationvalue1 + " - " + selectedpopulationvalue2;										
												var masterloopcount = 999999999999999999;
											}
										masterloopcount++;
									}
								outcomesarraydatarow.push(mergedcancertypetreatmentpair);
							}


						if (stylecheck1 > -1)
							{
								var styleposition1 = headerloopcount;
								
								var masterloopcount = 0;
								var colorstyleinsert = null;
								while (masterloopcount < newbasearray.length)
									{
										if (newbasearray[masterloopcount][patientposition] == selectedpatient)
											{
												var cancertypevalue = newbasearray[masterloopcount][cancertypeposition];
												var cancertypeshapeposition = cancertypelist.indexOf(cancertypevalue);
												var selectedshape = cancertypeshapesarray[cancertypeshapeposition];
												
												var treatmentvalue = newbasearray[masterloopcount][treatmentposition];
												var treatmentcolorposition = treatmentlist.indexOf(treatmentvalue);
												var selectedcolor = treatmentcolorsarray[treatmentcolorposition];
												
												var colorstyleinsert = 'point { size: 14; shape-type: ' + selectedshape + '; stroke-color: ' + selectedcolor + '; stroke-width: 3 }';
												
												//////Creating Array for Symbol and Color Identification in Selection Menus
												var mergedpairidentifier = cancertypevalue + " - " + treatmentvalue;
												var selectedshapehtmlcode = cancertypeshapesarrayhtmlcodes[cancertypeshapeposition];
												var singleformatarray = [mergedpairidentifier,selectedshapehtmlcode,selectedcolor];
												var countX = 0;
												var checkerX = 0;
												while (countX < cancertreatpairsselectionformat.length)
													{
														if (cancertreatpairsselectionformat[countX][0] == singleformatarray[0])
															{
																var checkerX = 9999999;
																var countX = 9999999;
															}
														countX++;
													}							
												if (checkerX < 1)
													{
														cancertreatpairsselectionformat.push(singleformatarray);
													}
													
													
												var masterloopcount = 999999999999999999;
											}
										masterloopcount++;
									}
								
								outcomesarraydatarow.push(colorstyleinsert);
							}
					

						if (stylecheck2 > -1)
							{
								var styleposition2 = headerloopcount;
								
								var masterloopcount = 0;
								var colorstyleinsert = null;
								while (masterloopcount < newbasearray.length)
									{
										if (newbasearray[masterloopcount][patientposition] == selectedpatient)
											{
												var cancertypevalue = newbasearray[masterloopcount][cancertypeposition];
												var cancertypeshapeposition = cancertypelist.indexOf(cancertypevalue);
												var selectedshape = cancertypeshapesarray[cancertypeshapeposition];
												
												var treatmentvalue = newbasearray[masterloopcount][treatmentposition];
												var treatmentcolorposition = treatmentlist.indexOf(treatmentvalue);
												var selectedcolor = treatmentcolorsarray[treatmentcolorposition];
												
												var colorstyleinsert = 'point { size: 9; shape-type: ' + selectedshape + '; stroke-color: ' + selectedcolor + '; stroke-width: 2';
												
												//////Creating Array for Symbol and Color Identification in Selection Menus
												var mergedpairidentifier = cancertypevalue + " - " + treatmentvalue;
												var selectedshapehtmlcode = cancertypeshapesarrayhtmlcodes[cancertypeshapeposition];
												var singleformatarray = [mergedpairidentifier,selectedshapehtmlcode,selectedcolor];
												var countX = 0;
												var checkerX = 0;
												while (countX < cancertreatpairsselectionformat.length)
													{
														if (cancertreatpairsselectionformat[countX][0] == singleformatarray[0])
															{
																var checkerX = 999999;
																var countX = 999999;
															}
														countX++;
													}							
												if (checkerX < 1)
													{
														cancertreatpairsselectionformat.push(singleformatarray);
													}
													
													
												var masterloopcount = 999999999999999999;
											}
										masterloopcount++;
									}
								
								outcomesarraydatarow.push(colorstyleinsert);
							}
			

						
						headerloopcount++;
					}
				MasterOutcomesArray.push(outcomesarraydatarow);
				AllRowsArray.push(patientcount);
				patientcount++;
				
			}
		
		var AllArrays = [MasterOutcomesArray, AllRowsArray, cancertreatpairsselectionformat];
		return AllArrays;
}






////Function to Construct Master Treatment-Cohort Array for COLUMN CHART/////////////////////
////Function to Construct Master Treatment-Cohort Array for COLUMN CHART/////////////////////
////Function to Construct Master Treatment-Cohort Array for COLUMN CHART/////////////////////

function createmastertreatmentcohortarray(newbasearray, MasterTreatmentCohortArrayHeaders, timepointlist, timepointposition, patientposition, treatmentlist, treatmentposition, groupsparentchildlist, populationlist, populationlistindex, outcomeslist, outcomeslistindex, groupslist, groupslistindex, cancertypeposition, NEWCancerTypeTreatmentShapeColorFormats) { 
	
	var MasterTreatmentCohortArray = [];
	var MasterTreatmentCohortArrayGOOGLE = [];
	MasterTreatmentCohortArray.push(MasterTreatmentCohortArrayHeaders);
	MasterTreatmentCohortArrayGOOGLE.push(MasterTreatmentCohortArrayHeaders);

	var MasterTreatmentCohortArrayInsertRow = [];
	var MasterTreatmentCohortArrayInsertRowGOOGLE = [];

	var count = 0;
	while (count < timepointlist.length)
		{
			temptimepoint = timepointlist[count];

			////Temporary Suspension of Treatment Sublist
			var countx = -1;
			while (countx < 0)
				{
					if (countx < 0)
						{
							var temptreatment = "ALL";
						}
					else
						{
							var temptreatment = treatmentlist[countx];
						}
					
					var count2 = -1;
					while (count2 < groupsparentchildlist.length)
						{
							if (count2 < 0)
								{
									var tempgroup = "ALL";
									var tempgroupselector = "-";
								}
							else
								{
									var tempgroup = groupsparentchildlist[count2];
									var tempcolonposition = tempgroup.indexOf(":");
									var tempgroupselector = tempgroup.substring(0, tempcolonposition);
									var tempgroupchild = tempgroup.substring((tempcolonposition + 2), tempgroup.length);
									var selectedgroupindex = groupslist.indexOf(tempgroupselector);
									var selectedgroupposition = groupslistindex[selectedgroupindex];
								}
							
							var count3 = 0;
							var MasterTreatmentCohortArrayInsertRow = [];
							var MasterTreatmentCohortArrayInsertRowGOOGLE = [];
							while (count3 < MasterTreatmentCohortArrayHeaders.length)
								{
									
									//alert(MasterTreatmentCohortArrayHeaders);
									var selectedheader = MasterTreatmentCohortArrayHeaders[count3];


									if (selectedheader == "Treatment")
										{
											var temptreatment2 = String(temptreatment);
											MasterTreatmentCohortArrayInsertRow.push(temptreatment2);
											MasterTreatmentCohortArrayInsertRowGOOGLE.push(temptreatment2);
										}
									
									if (selectedheader == "Group Subset")
										{
											var tempgroup2 = String(tempgroup);
											MasterTreatmentCohortArrayInsertRow.push(tempgroup2);
											MasterTreatmentCohortArrayInsertRowGOOGLE.push(tempgroup2);					
										}
									
									//////Create Timepoint SubHeaders//////							
									if (selectedheader == "Timepoint")
										{
											var temptimepoint2 = String(temptimepoint);
											MasterTreatmentCohortArrayInsertRow.push(temptimepoint2);
											
											if (tempgroup !== "ALL" && temptreatment == "ALL")
												{
													var temptimepoint3 = "Day " + temptimepoint2 + " {" + tempgroup + "}";
												}
															
											if (tempgroup == "ALL" && temptreatment == "ALL")
												{
													var temptimepoint3 = "Day " + temptimepoint2 + " {Total}";
													//alert(temptimepoint3);
												}
											
											MasterTreatmentCohortArrayInsertRowGOOGLE.push(temptimepoint3);
										}



									
									var headerparametercheck = selectedheader.indexOf(":");
									
									
									if (headerparametercheck > -1)
										{
											//alert(selectedheader);
											
											var firstcolonposition = selectedheader.indexOf(":");
											var selectedcohort = selectedheader.substring(0, firstcolonposition);
											var dashposition = selectedcohort.indexOf(" - ");
											var selectedcancertypevalue = selectedcohort.substring(0, dashposition);
											var selectedtreatmentvalue = selectedcohort.substring((dashposition + 3), selectedcohort.length);
											
											var selectedpopulation = selectedheader.substring((firstcolonposition + 2), selectedheader.length);
											var temppopulationindex = populationlist.indexOf(selectedpopulation);
											if (temppopulationindex < 0)
												{
													var temppopulationindex = outcomeslist.indexOf(selectedpopulation);
													var temppopulationposition = outcomeslistindex[temppopulationindex];
													
													if (temppopulationposition < 0)
														{
															alert("Can not locate this population: " + selectedpopulation);
														}
												}
											else
												{
													var temppopulationposition = populationlistindex[temppopulationindex];
												}

											//alert(temppopulationindex);
											//alert(temppopulationposition);
											
											var headervalueinnewbasearray = newbasearray[0][temppopulationposition];
											//alert(headervalueinnewbasearray);
		
											
											///Check for Comparison Timepoint///
											var istimepointcomparison = false;
											
											var comparisoncheck = temptimepoint2.indexOf(" vs ");
											//alert(temptimepoint2);
											if (comparisoncheck > 0)
												{
													var experimentaltimepoint = temptimepoint2.substring(0, comparisoncheck);
													var referencetimepoint = temptimepoint2.substring((comparisoncheck + 4), comparisoncheck.length);
													var istimepointcomparison = true;
												}
												
											var tempvaluescollection = [];
												
											if (istimepointcomparison == false)
												{	
													var tempvaluescollection = [];
													var count4 = 1;
													while (count4 < newbasearray.length)
														{
															
															var checktimepoint = newbasearray[count4][timepointposition];
															var checktimepoint = String(checktimepoint);
															var checktreatment = newbasearray[count4][treatmentposition];
															var checkcancertype = newbasearray[count4][cancertypeposition];
									
															if (tempgroup !== "ALL")
																{
																	var checkgroup = newbasearray[count4][selectedgroupposition];
																}
																
															
															if (tempgroup == "ALL" && temptreatment !== "ALL")
																{
																	if (checktimepoint == temptimepoint2 && checktreatment == temptreatment && (checkcancertype == selectedcancertypevalue || selectedcancertypevalue == "Composite") && selectedtreatmentvalue == checktreatment)
																		{
																			var tempparametervalue = newbasearray[count4][temppopulationposition];
																			if (tempparametervalue !== null && tempparametervalue !== "NULL" && tempparametervalue.length > 0)
																				{
																					var tempparametervalue = Number(tempparametervalue);
																					if (isNaN(tempparametervalue) == false)
																						{
																							tempvaluescollection.push(tempparametervalue);
																						}
																				}
																		}
																}

															if (tempgroup !== "ALL" && temptreatment == "ALL")
																{
																	if (checktimepoint == temptimepoint2 && checkgroup == tempgroupchild && (checkcancertype == selectedcancertypevalue || selectedcancertypevalue == "Composite") && selectedtreatmentvalue == checktreatment)
																		{
																			var tempparametervalue = newbasearray[count4][temppopulationposition];
																			if (tempparametervalue !== null && tempparametervalue !== "NULL" && tempparametervalue.length > 0)
																				{
																					var tempparametervalue = Number(tempparametervalue);
																					if (isNaN(tempparametervalue) == false)
																						{
																							tempvaluescollection.push(tempparametervalue);
																						}
																				}
																		}
																}

															if (tempgroup !== "ALL" && temptreatment !== "ALL")
																{
																	if (checktimepoint == temptimepoint2 && checktreatment == temptreatment && (checkcancertype == selectedcancertypevalue || selectedcancertypevalue == "Composite") && checkgroup == tempgroupchild && selectedtreatmentvalue == checktreatment)
																		{
																			var tempparametervalue = newbasearray[count4][temppopulationposition];
																			//alert("Parameter: " + selectedpopulation + "Parameter Value: " + tempparametervalue + " Timepoint: " + temptimepoint + " Cancer Type: " + selectedcancertypevalue + " Group: " + tempgroup + " Treatment: " + temptreatment + " Values: " + tempvaluescollection);
																			if (tempparametervalue !== null && tempparametervalue !== "NULL" && tempparametervalue.length > 0)
																				{
																					var tempparametervalue = Number(tempparametervalue);
																					if (isNaN(tempparametervalue) == false)
																						{
																							tempvaluescollection.push(tempparametervalue);
																						}
																				}
																		}
																}


															if (tempgroup == "ALL" && temptreatment == "ALL")
																{	
																	if (checktimepoint == temptimepoint2 && (checkcancertype == selectedcancertypevalue || selectedcancertypevalue == "Composite") && selectedtreatmentvalue == checktreatment)
																		{
																			var tempparametervalue = newbasearray[count4][temppopulationposition];
																			if (tempparametervalue !== null && tempparametervalue !== "NULL" && tempparametervalue.length > 0)
																				{
																					var tempparametervalue = Number(tempparametervalue);
																					if (isNaN(tempparametervalue) == false)
																						{
																							tempvaluescollection.push(tempparametervalue);
																						}
																				}
																		}
																}																								
															count4++;
														}
												}
															
															

											if (istimepointcomparison == true)
												{
													var tempvaluescollection = [];															
															
															if (tempgroup == "ALL" && temptreatment !== "ALL")
																{	
																	//alert('tempgroup == "ALL" && temptreatment !== "ALL"');
																	var count6 = 0;
																	while (count6 < newbasearray.length)
																		{
																			var checktimepoint = newbasearray[count6][timepointposition];
																			var checktimepoint = String(checktimepoint);
																			var checkpatientID = newbasearray[count6][patientposition];
																			var checktreatment = newbasearray[count6][treatmentposition];
																			var checkcancertype = newbasearray[count6][cancertypeposition];																																							
																			if (tempgroup !== "ALL")
																				{
																					var checkgroup = newbasearray[count6][selectedgroupposition];
																				}
																			
																			if (checktimepoint == referencetimepoint && checktreatment == temptreatment && (checkcancertype == selectedcancertypevalue || selectedcancertypevalue == "Composite") && selectedtreatmentvalue == checktreatment)
																				{
																					var tempparametervalueREFERENCE = newbasearray[count6][temppopulationposition];
																					if (tempparametervalueREFERENCE !== null && tempparametervalueREFERENCE !== "NULL" && tempparametervalueREFERENCE.length > 0)
																						{
																							var count7 = 0;
																							while (count7 < newbasearray.length)
																								{																						
																									var checktimepoint2 = newbasearray[count7][timepointposition];
																									var checktimepoint2 = String(checktimepoint2);
																									var checkpatientID2 = newbasearray[count7][patientposition];
																									var checktreatment2 = newbasearray[count7][treatmentposition];
																									var checkcancertype2 = newbasearray[count7][cancertypeposition];																				
																									if (tempgroup !== "ALL")
																										{
																											var checkgroup2 = newbasearray[count7][selectedgroupposition];
																										}

																									
																									if (checkpatientID == checkpatientID2 && checktimepoint2 == experimentaltimepoint && checktreatment2 == temptreatment && (checkcancertype2 == selectedcancertypevalue || selectedcancertypevalue == "Composite") && selectedtreatmentvalue == checktreatment2)
																										{
																											var tempparametervalueEXPERIMENTAL = newbasearray[count7][temppopulationposition];
																											if (tempparametervalueEXPERIMENTAL !== null && tempparametervalueEXPERIMENTAL !== "NULL" && tempparametervalueEXPERIMENTAL.length > 0)
																												{
																													var tempparametervalueREFERENCE = Number(tempparametervalueREFERENCE);
																													var tempparametervalueEXPERIMENTAL = Number(tempparametervalueEXPERIMENTAL);
																													var tempparametervalueDIFFERENTIAL = tempparametervalueEXPERIMENTAL - tempparametervalueREFERENCE;
																													var tempparametervalueDIFFERENTIAL = Math.round(tempparametervalueDIFFERENTIAL * 100);
																													var tempparametervalueDIFFERENTIAL = tempparametervalueDIFFERENTIAL / 100;
																													if (isNaN(tempparametervalueDIFFERENTIAL) == false)
																														{
																															tempvaluescollection.push(tempparametervalueDIFFERENTIAL);
																														}
																												}
																										}
																									count7++;
																								}
																						}
																				}
																			count6++;
																		}
																}
																											


															if (tempgroup !== "ALL" && temptreatment == "ALL")
																{	
																	//alert('tempgroup !== "ALL" && temptreatment == "ALL"');
																	var count6 = 0;
																	while (count6 < newbasearray.length)
																		{
																			var checktimepoint = newbasearray[count6][timepointposition];
																			var checktimepoint = String(checktimepoint);
																			var checkpatientID = newbasearray[count6][patientposition];
																			var checktreatment = newbasearray[count6][treatmentposition];
																			var checkcancertype = newbasearray[count6][cancertypeposition];																																							
																			if (tempgroup !== "ALL")
																				{
																					var checkgroup = newbasearray[0][selectedgroupposition] + ": " + newbasearray[count6][selectedgroupposition];
																				}
																		
																			if (checktimepoint == referencetimepoint && checkgroup == tempgroup && (checkcancertype == selectedcancertypevalue || selectedcancertypevalue == "Composite") && selectedtreatmentvalue == checktreatment)
																				{
																					
																					var tempparametervalueREFERENCE = newbasearray[count6][temppopulationposition];
																					if (tempparametervalueREFERENCE !== null && tempparametervalueREFERENCE !== "NULL" && tempparametervalueREFERENCE.length > 0)
																						{
																							var count7 = 0;
																							while (count7 < newbasearray.length)
																								{																						
																									var checktimepoint2 = newbasearray[count7][timepointposition];
																									var checktimepoint2 = String(checktimepoint2);
																									var checkpatientID2 = newbasearray[count7][patientposition];
																									var checktreatment2 = newbasearray[count7][treatmentposition];
																									var checkcancertype2 = newbasearray[count7][cancertypeposition];																				
																									if (tempgroup !== "ALL")
																										{
																											var checkgroup2 = newbasearray[0][selectedgroupposition] + ": " + newbasearray[count7][selectedgroupposition];
																										}

																									
																									if (checktimepoint2 == experimentaltimepoint && checkgroup2 == tempgroup && (checkcancertype2 == selectedcancertypevalue || selectedcancertypevalue == "Composite") && selectedtreatmentvalue == checktreatment2)
																										{
																											var tempparametervalueEXPERIMENTAL = newbasearray[count7][temppopulationposition];
																											if (tempparametervalueEXPERIMENTAL !== null && tempparametervalueEXPERIMENTAL !== "NULL" && tempparametervalueEXPERIMENTAL.length > 0)
																												{
																													var tempparametervalueREFERENCE = Number(tempparametervalueREFERENCE);
																													var tempparametervalueEXPERIMENTAL = Number(tempparametervalueEXPERIMENTAL);
																													var tempparametervalueDIFFERENTIAL = tempparametervalueEXPERIMENTAL - tempparametervalueREFERENCE;
																													var tempparametervalueDIFFERENTIAL = Math.round(tempparametervalueDIFFERENTIAL * 100);
																													var tempparametervalueDIFFERENTIAL = tempparametervalueDIFFERENTIAL / 100;
																													if (isNaN(tempparametervalueDIFFERENTIAL) == false)
																														{
																															tempvaluescollection.push(tempparametervalueDIFFERENTIAL);
																														}
																												}
																										}
																									count7++;
																								}
																						}
																				}
																			count6++;
																		}
																}

															if (tempgroup !== "ALL" && temptreatment !== "ALL")
																{	
																	//alert('tempgroup !== "ALL" && temptreatment !== "ALL"');
																	var count6 = 0;
																	while (count6 < newbasearray.length)
																		{
																			var checktimepoint = newbasearray[count6][timepointposition];
																			var checktimepoint = String(checktimepoint);
																			var checkpatientID = newbasearray[count6][patientposition];
																			var checktreatment = newbasearray[count6][treatmentposition];
																			var checkcancertype = newbasearray[count6][cancertypeposition];																																							
																			if (tempgroup !== "ALL")
																				{
																					var checkgroup = newbasearray[count6][selectedgroupposition];
																				}
																		
																		
																			if (checktimepoint == referencetimepoint && checktreatment == temptreatment && (checkcancertype == selectedcancertypevalue || selectedcancertypevalue == "Composite") && checkgroup == tempgroup && selectedtreatmentvalue == checktreatment)
																				{
																					var tempparametervalueREFERENCE = newbasearray[count6][temppopulationposition];
																					if (tempparametervalueREFERENCE !== null && tempparametervalueREFERENCE !== "NULL" && tempparametervalueREFERENCE.length > 0)
																						{
																							var count7 = 0;
																							while (count7 < newbasearray.length)
																								{																						
																									var checktimepoint2 = newbasearray[count7][timepointposition];
																									var checktimepoint2 = String(checktimepoint2);
																									var checkpatientID2 = newbasearray[count7][patientposition];
																									var checktreatment2 = newbasearray[count7][treatmentposition];
																									var checkcancertype2 = newbasearray[count7][cancertypeposition];																				
																									if (tempgroup !== "ALL")
																										{
																											var checkgroup2 = newbasearray[count7][selectedgroupposition];
																										}

																									
																									if (checkpatientID == checkpatientID2 && checktimepoint2 == experimentaltimepoint && checktreatment2 == temptreatment && (checkcancertype2 == selectedcancertypevalue || selectedcancertypevalue == "Composite") && checkgroup2 == tempgroup && selectedtreatmentvalue == checktreatment2)
																										{
																											var tempparametervalueEXPERIMENTAL = newbasearray[count7][temppopulationposition];
																											if (tempparametervalueEXPERIMENTAL !== null && tempparametervalueEXPERIMENTAL !== "NULL" && tempparametervalueEXPERIMENTAL.length > 0)
																												{
																													var tempparametervalueREFERENCE = Number(tempparametervalueREFERENCE);
																													var tempparametervalueEXPERIMENTAL = Number(tempparametervalueEXPERIMENTAL);
																													var tempparametervalueDIFFERENTIAL = tempparametervalueEXPERIMENTAL - tempparametervalueREFERENCE;
																													var tempparametervalueDIFFERENTIAL = Math.round(tempparametervalueDIFFERENTIAL * 100);
																													var tempparametervalueDIFFERENTIAL = tempparametervalueDIFFERENTIAL / 100;
																													if (isNaN(tempparametervalueDIFFERENTIAL) == false)
																														{
																															tempvaluescollection.push(tempparametervalueDIFFERENTIAL);
																														}
																												}
																										}
																									count7++;
																								}
																						}
																				}
																			count6++;
																		}
																}


															if (tempgroup == "ALL" && temptreatment == "ALL")
																{	
																	var count6 = 0;
																	while (count6 < newbasearray.length)
																		{
																			var checktimepoint = newbasearray[count6][timepointposition];
																			var checkpatientID = newbasearray[count6][patientposition];
																			var checktimepoint = String(checktimepoint);
																			var checktreatment = newbasearray[count6][treatmentposition];
																			var checkcancertype = newbasearray[count6][cancertypeposition];																																							
																			if (tempgroup !== "ALL")
																				{
																					var checkgroup = newbasearray[count6][selectedgroupposition];
																				}
																		
																		
																			if (checktimepoint == referencetimepoint && (checkcancertype == selectedcancertypevalue || selectedcancertypevalue == "Composite") && selectedtreatmentvalue == checktreatment)
																				{
																					var tempparametervalueREFERENCE = newbasearray[count6][temppopulationposition];
																					if (tempparametervalueREFERENCE !== null && tempparametervalueREFERENCE !== "NULL" && tempparametervalueREFERENCE.length > 0)
																						{
																							var count7 = 0;
																							while (count7 < newbasearray.length)
																								{																						
																									var checktimepoint2 = newbasearray[count7][timepointposition];
																									var checktimepoint2 = String(checktimepoint2);
																									var checkpatientID2 = newbasearray[count7][patientposition];
																									var checktreatment2 = newbasearray[count7][treatmentposition];
																									var checkcancertype2 = newbasearray[count7][cancertypeposition];																				
																									if (tempgroup !== "ALL")
																										{
																											var checkgroup2 = newbasearray[count7][selectedgroupposition];
																										}

																									
																									if (checkpatientID == checkpatientID2 && checktimepoint2 == experimentaltimepoint && (checkcancertype2 == selectedcancertypevalue || selectedcancertypevalue == "Composite") && selectedtreatmentvalue == checktreatment2)
																										{
																											var tempparametervalueEXPERIMENTAL = newbasearray[count7][temppopulationposition];
																											if (tempparametervalueEXPERIMENTAL !== null && tempparametervalueEXPERIMENTAL !== "NULL" && tempparametervalueEXPERIMENTAL.length > 0)
																												{
																													var tempparametervalueREFERENCE = Number(tempparametervalueREFERENCE);
																													var tempparametervalueEXPERIMENTAL = Number(tempparametervalueEXPERIMENTAL);
																													var tempparametervalueDIFFERENTIAL = tempparametervalueEXPERIMENTAL - tempparametervalueREFERENCE;
																													var tempparametervalueDIFFERENTIAL = Math.round(tempparametervalueDIFFERENTIAL * 100);
																													var tempparametervalueDIFFERENTIAL = tempparametervalueDIFFERENTIAL / 100;
																													if (isNaN(tempparametervalueDIFFERENTIAL) == false)
																														{
																															tempvaluescollection.push(tempparametervalueDIFFERENTIAL);
																														}
																												}
																										}
																									count7++;
																								}
																						}
																				}
																			count6++;
																		}
																}																							
														}													
											
												
											var tempmeansandintervals = calculatemeanandintervals(tempvaluescollection);
					
											var InsertMeanValue = tempmeansandintervals[0];
											var InsertSTD = tempmeansandintervals[1];
											var InsertLowInterval = tempmeansandintervals[2];
											var InsertHighInterval = tempmeansandintervals[3];													
											var InsertAllValues = tempvaluescollection;
											
											var InsertStyle = "";
											var selectedtreatmentcolor = "Black";
											var selectedcancertypeshape = "";
											var colorcount = 0;
											while (colorcount < NEWCancerTypeTreatmentShapeColorFormats.length)
												{
													var cohortselection = NEWCancerTypeTreatmentShapeColorFormats[colorcount][0];
													if (cohortselection == selectedcohort)
														{
															var selectedtreatmentcolor = NEWCancerTypeTreatmentShapeColorFormats[colorcount][2];
															var selectedcancertypeshape = NEWCancerTypeTreatmentShapeColorFormats[colorcount][1];
															var selectedcancertypecolor = NEWCancerTypeTreatmentShapeColorFormats[colorcount][3];
															var colorcount = 9999999999999;
														}
													colorcount++;
												}
											//var InsertStyle = "color: gold; opacity: 0.8; stroke-color: " + selectedtreatmentcolor + "; stroke-width: 4";
											var InsertStyle = "color: " + selectedcancertypecolor + "; opacity: 0.8; stroke-color: " + selectedtreatmentcolor + "; stroke-width: 4";	
											var InsertAnnotation = selectedpopulation;
											var InsertMoreInfo = selectedcancertypecolor;
											
											MasterTreatmentCohortArrayInsertRow.push(InsertMeanValue, InsertAllValues, InsertLowInterval, InsertHighInterval, InsertStyle, InsertAnnotation, InsertMoreInfo);
											MasterTreatmentCohortArrayInsertRowGOOGLE.push(InsertMeanValue, InsertAnnotation, InsertLowInterval, InsertHighInterval, InsertStyle, InsertAnnotation, InsertMoreInfo);
											//alert("Parameter: " + selectedpopulation + " Timepoint: " + temptimepoint + " Cancer Type: " + selectedcancertypevalue + " Group: " + tempgroup + " Treatment: " + temptreatment + " Values: " + tempvaluescollection);
										}
									
									count3++;
									
								}
							
							/////Add Spacer Column//////
							MasterTreatmentCohortArrayInsertRow.push(0, [0], 0, 0, "opacity: 0.1", "", "");
							MasterTreatmentCohortArrayInsertRowGOOGLE.push(0, "", 0, 0, "opacity: 0.1", "", "");
							
							MasterTreatmentCohortArray.push(MasterTreatmentCohortArrayInsertRow);
							//alert(MasterTreatmentCohortArrayInsertRow);
							MasterTreatmentCohortArrayGOOGLE.push(MasterTreatmentCohortArrayInsertRowGOOGLE);


							count2++;
						}
					countx++;
				}
			count++;
		}

	var BothMasterArrays = [MasterTreatmentCohortArray, MasterTreatmentCohortArrayGOOGLE];

	return BothMasterArrays;

}





































////Functions to Define Selections///////////////////////////////////////////////////////////////////////////////////
////Functions to Define Selections///////////////////////////////////////////////////////////////////////////////////
////Functions to Define Selections///////////////////////////////////////////////////////////////////////////////////
////Functions to Define Selections///////////////////////////////////////////////////////////////////////////////////
////Functions to Define Selections///////////////////////////////////////////////////////////////////////////////////

///Determine which outcomes are selected////////
///Determine which outcomes are selected////////
function determineselectedoutcomes(outcomeslist) {
	
	count = 0;
	var checkedoutcomes = [];
	while (count < outcomeslist.length)
		{
		var tempvalue1 = outcomeslist[count];
		var tempvalue2 = document.getElementById(tempvalue1);
		if (tempvalue2.checked){checkedoutcomes.push(tempvalue1);}
		count++;
		};
	if (checkedoutcomes.length < 1) {alert("You have not selected an outcome. You will see the default selection (" + outcomeslist[0] +")");};
	
	return checkedoutcomes;
}


////Determine Selected Timepoints////////////
////Determine Selected Timepoints////////////
function determineselectedtimepoints(timepointlist) {
	count = 0;
	var checkedtimepoints = [];
	while (count < timepointlist.length)
		{
		var tempvalue1 = timepointlist[count];
		var tempvalue2 = document.getElementById(tempvalue1);
		if (tempvalue2.checked){checkedtimepoints.push(tempvalue1);}
		count++;
		var tempvalue3 = document.getElementById('SelectAllTimepoints');
		if (tempvalue3.checked)
			{
				checkedtimepoints = timepointlist;
				count = 9999999999999;
			}
		}	
	if (checkedtimepoints.length < 1) 
		{
			alert("You must select at least one timepoint. You will see the defualt timepoint (Day " + timepointlist[0] + ")");
			checkedtimepoints.push(timepointlist[0]);
		}
	
	return checkedtimepoints;
}


////Determine Which Parameters Are Selected for OUTCOMES ANALYSIS///
////Determine Which Parameters Are Selected for OUTCOMES ANALYSIS///
function determineselectedparameters(populationlist) {
	count = 0;
	var checkedparameters = [];
	while (count < populationlist.length)
		{
		var tempvalue1 = populationlist[count];
		var tempvalue2 = document.getElementById(tempvalue1);
		if (tempvalue2.checked){checkedparameters.push(tempvalue1);}
		count++;
		var tempvalue3 = document.getElementById('SelectAllParameters');
		if (tempvalue3.checked)
			{
				checkedparameters = populationlist;
				count = 9999999999999;
			}
		};
	if (checkedparameters.length < 1) 
		{
			alert("You must select at least one parameter. You will see the default (" + populationlist[0] + ")");
			checkedparameters.push(populationlist[0]);
		};
	
	return checkedparameters;
}


////Determine Which Parameters Are Selected for COLUMN CHART///
////Determine Which Parameters Are Selected for COLUMN CHART///
function determineselectedparametersCOLUMN(populationlist, outcomeslist) {
	count = 0;
	var checkedparameters = [];
	while (count < populationlist.length)
		{
			var tempvalue1 = populationlist[count];
			var tempvalue2 = document.getElementById(tempvalue1);
			if (tempvalue2.checked){checkedparameters.push(tempvalue1);}
			count++;
			var tempvalue3 = document.getElementById('SelectAllParameters');
			if (tempvalue3.checked)
				{
					checkedparameters = populationlist;
					count = 9999999999999;
				}
		};

	count = 0;
	while (count < outcomeslist.length)
		{
			var tempvalue1 = outcomeslist[count];
			var tempvalue2 = document.getElementById(tempvalue1);
			if (tempvalue2.checked){checkedparameters.push(tempvalue1);}
			count++;
		}

	if (checkedparameters.length < 1) 
		{
			alert("You must select at least one parameter. You will see the default (" + populationlist[0] + ")");
			checkedparameters.push(populationlist[0]);
		};
	
	return checkedparameters;
}


////Determine Which Cohorts Are Selected for OUTCOMES CHART/////
////Determine Which Cohorts Are Selected for OUTCOMES CHART/////
function determineselectedcohorts(cancertypetreatpairrowsarray, AllRowsArray) {

	count = 0;
	var checkedcohorts = [];
	while (count < cancertypetreatpairrowsarray.length)
		{
		var tempvalue1 = cancertypetreatpairrowsarray[count][0];
		var tempvalue2 = document.getElementById(tempvalue1);
		if (tempvalue2.checked)
			{
				var subsetrows = cancertypetreatpairrowsarray[count][1];
				var countZ = 0;
				while (countZ < subsetrows.length)
					{
						checkedcohorts.push(subsetrows[countZ]);
						countZ++;
					}
			}
		count++;
		var tempvalue3 = document.getElementById('SelectAllcancertreatpairs');
		if (tempvalue3.checked)
			{
				checkedcohorts = AllRowsArray;
				count = 9999999999999;
			}
		};
	if (checkedcohorts.length < 1) 
		{
			alert("You must select at least one cohort. You will now see the default (all cohorts).");
			checkedcohorts = AllRowsArray;
		};
		
	return checkedcohorts;
}


/////Determine Which Groups Are Selected for OUTCOMES CHART/////
/////Determine Which Groups Are Selected for OUTCOMES CHART/////
function determineselectedgroups(AllGroupSubsetArrays) {
	
	var groupsubsetuniquelist = AllGroupSubsetArrays[0];
	var groupsubsetrowarray = AllGroupSubsetArrays[1];
	var count = 0;
	var checkedgroups = [];
	var checkedgroupsnames = [];
	var parentgroupnames = [];
	
	var tempvalue3 = document.getElementById('SelectAllGroups');
	if (tempvalue3.checked)
		{
			var count = 0;
			while (count < groupsubsetuniquelist.length)
				{
					var tempvalue1 = groupsubsetuniquelist[count];
					var subsetrows = [];
					var subsetrows = groupsubsetrowarray[count];
					checkedgroups.push(subsetrows);
					checkedgroupsnames.push(tempvalue1);
					var parentgroupvaluedelimiter = tempvalue1.indexOf(":");
					var parentgroupvalue = tempvalue1.substring(0,parentgroupvaluedelimiter);
					parentgroupnames.push(parentgroupvalue);
					count++;
				}
		}
	else
		{
			var count = 0;
			while (count < groupsubsetuniquelist.length)
				{	
					var tempvalue1 = groupsubsetuniquelist[count];
					var tempvalue2 = document.getElementById(tempvalue1);
					if (tempvalue2.checked)
						{
							var subsetrows = [];
							var subsetrows = groupsubsetrowarray[count];
							checkedgroups.push(subsetrows);
							checkedgroupsnames.push(tempvalue1);
							var parentgroupvaluedelimiter = tempvalue1.indexOf(":");
							var parentgroupvalue = tempvalue1.substring(0,parentgroupvaluedelimiter);
							parentgroupnames.push(parentgroupvalue);
						}
					count++;
				}
		}
	if (checkedgroups.length < 1) 
		{
			alert("You must select at least one groups. You will now see the default (all groups).");

			var count = 0;
			while (count < groupsubsetuniquelist.length)
				{
					var tempvalue1 = groupsubsetuniquelist[count];
					var subsetrows = [];
					var subsetrows = groupsubsetrowarray[count];
					checkedgroups.push(subsetrows);
					checkedgroupsnames.push(tempvalue1);
					var parentgroupvaluedelimiter = tempvalue1.indexOf(":");
					var parentgroupvalue = tempvalue1.substring(0,parentgroupvaluedelimiter);
					parentgroupnames.push(parentgroupvalue);
					count++;
				}
			
		}
	
	var groupselectionarrays = [checkedgroups, checkedgroupsnames, parentgroupnames];
	return groupselectionarrays;
}

/////////Determine Which Cohorts Are Selected for COLUMN CHART////////
/////////Determine Which Cohorts Are Selected for COLUMN CHART////////
	function determineselectedcohortsNOROWS(cancertypetreatmentpairlist) {

		count = 0;
		var checkedcohorts = [];
		while (count < cancertypetreatmentpairlist.length)
			{
				
				var tempvalue1 = cancertypetreatmentpairlist[count];
				var tempvalue2 = document.getElementById(tempvalue1);
				
				if (tempvalue2.checked){checkedcohorts.push(tempvalue1);}
				var tempvalue3 = document.getElementById('SelectAllcancertreatpairs');
				if (tempvalue3.checked)
					{
						checkedcohorts = cancertypetreatmentpairlist;
						count = 9999999999999;
					}
					
				count++;
			}
		if (checkedcohorts.length < 1) 
			{
				alert("You must select at least one cohort");
			}
		
		return checkedcohorts;
	}





//////Resolve Group Row Selections for OUTCOMES CHART////////
//////Resolve Group Row Selections for OUTCOMES CHART////////	
/////Construct Unique Group Parent List and Concatenated Row lists////
function getrowsforgroupselections(parentgroupnames, checkedgroups, checkedgroupsnames) {

	var uniqueparentlistnames = [];
	var simplifiedparentrowarray = [];
	var newrowarray = [];
	
	var count = 0;
	while (count < parentgroupnames.length)
		{
			var selectedparentgroupname = parentgroupnames[count];
			var newrowarray = checkedgroups[count];
			var uniqueparentcheck = uniqueparentlistnames.indexOf(selectedparentgroupname);
			
			if (uniqueparentcheck == -1)
				{
					uniqueparentlistnames.push(selectedparentgroupname);
					var existingarray = newrowarray;
				}
			if (uniqueparentcheck > -1)
				{
					var arraytoappend = newrowarray;
					var combinedarray = existingarray.concat(arraytoappend);
					var existingarray = combinedarray;
				}
			if (parentgroupnames[(count + 1)] !== selectedparentgroupname)
				{
					simplifiedparentrowarray.push(existingarray);
				}	
			count++;
		}

/////////////NEED TO COMBINE ROW SETS WITHIN GROUP PARENTS//////////////////
//////Resolve Group Row Selections////////
	var finalgrouprowlist = [];
	var count = 0;
	while (count < simplifiedparentrowarray.length)
		{
			var count2 = 0;
			while (count2 < simplifiedparentrowarray[count].length)
				{
					var selectedgrouprow = simplifiedparentrowarray[count][count2];
					var sharedvalue = 1;
					var count3 = 0;
					while (count3 < simplifiedparentrowarray.length)
						{	
							var rowsubsettocheck = simplifiedparentrowarray[count3];
							var sharedchecker = rowsubsettocheck.indexOf(selectedgrouprow);
							if (sharedchecker < 0)
								{
									var sharedvalue = -1;
								}
							count3++;
						}				
				
					if (sharedvalue > 0)
						{
							var uniquecheck = finalgrouprowlist.indexOf(selectedgrouprow);
							if (uniquecheck < 0)
								{
									finalgrouprowlist.push(selectedgrouprow);
								}
						}
					count2++;
				}
			count++;
		}

/////Apply -1 to each row value in the group list to make it match the format (start at 0) for the Google Charts visualization///////////
	
	var finalgrouprowlistADJUSTED = [];
	var count = 0;
	while (count < finalgrouprowlist.length)
		{
			var adjustedvalue = finalgrouprowlist[count] - 1;
			finalgrouprowlistADJUSTED.push(adjustedvalue);
			count++;
		}

	return finalgrouprowlistADJUSTED;
}
	








///////////Functions to Define Dataview for Google Charts///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////Functions to Define Dataview for Google Charts///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////Functions to Define Dataview for Google Charts///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////Functions to Define Dataview for Google Charts///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////Functions to Define Dataview for Google Charts///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



/////Resolve the Rows to Show (Integrate Groups and Cohorts Selections) for OUTCOMES CHART////		
/////Resolve the Rows to Show (Integrate Groups and Cohorts Selections) for OUTCOMES CHART////	
function integrategroupandcohortrows(checkedcohorts, finalgrouprowlistADJUSTED, styleposition1, styleposition2) {
	var CohortRowsToShow = checkedcohorts;
	var GroupRowsToShow = finalgrouprowlistADJUSTED;
	var ResolvedRowsToShow = [];
	var count = 0;
	while (count < GroupRowsToShow.length)
		{
			var RowToCheck = GroupRowsToShow[count];
			var RowToCheckValue = CohortRowsToShow.indexOf(RowToCheck);
			if (RowToCheckValue > -1)
				{
					ResolvedRowsToShow.push(RowToCheck);
				}
			count++;
		}

	if (ResolvedRowsToShow.length < 1)
		{
			alert("There are no individuals that meet all of the selected parameters (groups and cohorts). As a placeholder, group selections will be ignored.");
			ResolvedRowsToShow = CohortRowsToShow;
		}

	var RowsToShow = ResolvedRowsToShow;
	////Assign Style Parameters Based on Number of Rows
	if (RowsToShow.length < 30 )
		{
			var adaptivestyle = styleposition1;
		}
	else
		{
			var adaptivestyle = styleposition2;
		}
	
	var ResolvedRowsReturn = [RowsToShow, adaptivestyle];
	return ResolvedRowsReturn;
}


////Determine Which Columns to Show for OUTCOMES CHART/////
////Determine Which Columns to Show for OUTCOMES CHART/////
function definecolumnstoshow(MasterOutcomesArray, checkedoutcomes, checkedtimepoints, checkedparameters, adaptivestyle, firstoutcomeposition, firstpopulationposition,styleposition1) {

	var ColumnsToShow = [];
	var OutcomeCount = 0;
	var nullalert = -1;

	var count = 1;
	while (count < MasterOutcomesArray[0].length) {
		var SelectedColumn = MasterOutcomesArray[0][count];

		
		//Check if Outcome is Selected
		var count2 = 0;
		
		var OutcomeValueInIndex = -1;
		while (count2 < checkedoutcomes.length) {
			var SelectedValue = checkedoutcomes[count2];
			var ValueChecker = SelectedColumn.indexOf(SelectedValue);
			if (ValueChecker > -1) {
				var OutcomeValueInIndex = 1;
				
				var nullcheck = -1;
				var nullcount = 1;
				while (nullcount < MasterOutcomesArray.length)
					{
						var checkvalue = MasterOutcomesArray[nullcount][count];
						if (checkvalue != null)
							{
								var nullcheck = 1;
								var nullcount = 999999999999;
							}
						nullcount++;
					}
				if (nullcheck == 1)
					{
						ColumnsToShow.push(count);
						var SelectedRadioOutcome = MasterOutcomesArray[0][count];
						OutcomeCount = 9999999999;
					}
			}
			count2++;
		}

		///////////////////////
		///////////////////////////
		/////////////////////////
		//////////////////////
		//Check if Timepoint is Selected
		var count2 = 0;
		var TimepointValueInIndex = -1;
		while (count2 < checkedtimepoints.length) { 
			var SelectedValue = checkedtimepoints[count2] + ":";
					
			var timepointcolonposition = SelectedColumn.indexOf(":");
			var columntimepoint = SelectedColumn.substring(0, (timepointcolonposition + 1));
			
			if (columntimepoint == SelectedValue) 
				{
					var TimepointValueInIndex = 1;
				}
			count2++;
		}
			

		//Check if Parameter is Selected
		var count2 = 0;
		var ParameterValueInIndex = -1;
		while (count2 < checkedparameters.length) {
			var SelectedValue = checkedparameters[count2];
			var ValueChecker = SelectedColumn.indexOf(SelectedValue);
			if (ValueChecker > -1) {
				var ParameterValueInIndex = 1;
				}
			count2++;
		}		

		if (TimepointValueInIndex == 1 && ParameterValueInIndex == 1) 
			{
				var nullcheck = -1;
				var nullcount = 1;
				while (nullcount < MasterOutcomesArray.length)
					{
						var checkvalue = MasterOutcomesArray[nullcount][count];
						if (checkvalue != null && checkvalue > -10000000)
							{
								var nullcheck = 1;
								var nullcount = 999999999999;
							}
						nullcount++;
					}
				if (nullcheck == 1)
					{
						ColumnsToShow.push(count,adaptivestyle);
					}
				else {var nullalert = 1;}
			}
		
		count++;
	}


	if (nullalert == 1) {alert("Some of the selected relationships do not have data. Only relationships with sufficient data will be shown.");}
	if (ColumnsToShow.length < 2 || OutcomeCount < 1) 
		{
			alert("There is no data for any of the selected relationships, you will see a default view");
			var ColumnsToShow = [];
			ColumnsToShow.push(firstoutcomeposition,firstpopulationposition,styleposition1);
		}

	return ColumnsToShow;
}



//////////Determine which groups are selected for COLUMN CHART/////////////
//////////Determine which groups are selected for COLUMN CHART/////////////
	function defineselectedgroupsCOLUMN(groupsparentchildlist) {
		
		var checkedgroups = [];
		var tempvalue2 = document.getElementById('TotalGroups');
		if (tempvalue2.checked)
			{
				checkedgroups.push('ALL');
			}
		
		var count = 0;
		while (count < groupsparentchildlist.length)
			{
				
				var tempvalue1 = groupsparentchildlist[count];
				var tempvalue2 = document.getElementById(tempvalue1);
				
				if (tempvalue2.checked)
					{
						checkedgroups.push(tempvalue1);
					}
					
				count++;
			}
		if (checkedgroups.length < 1) 
			{
				alert("You must select at least one group. You will now see the default {Total}.");
			}
		
		return checkedgroups;
	}

























/////Functions to Build Selection Boxes///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////Functions to Build Selection Boxes///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////Functions to Build Selection Boxes///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////Functions to Build Selection Boxes///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////Functions to Build Selection Boxes///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/////////Build Outcomes Selection Boxes for OUTCOMES CHART/////////
/////////Build Outcomes Selection Boxes for OUTCOMES CHART/////////
function buildoutcomesselectionboxes(outcomeslist) {
	
	var outcomescheckboxeshtml = "";;
	count = 0;
	while (count < outcomeslist.length)
		{
		outcomescheckboxeshtml += '<div><input type="radio" '; 
		if (count == 0)
			{
				outcomescheckboxeshtml += ' checked="checked" ';
			}
		outcomescheckboxeshtml += 'id="';
		outcomescheckboxeshtml += outcomeslist[count];
		outcomescheckboxeshtml += '" name="outcomes" > ';
		outcomescheckboxeshtml += outcomeslist[count];
		outcomescheckboxeshtml += '<br></div>';
		count++;
		}
	
	return outcomescheckboxeshtml;
}


///////Build Timepoint Selection Boxes/////
///////Build Timepoint Selection Boxes/////
function buildtimepointselectionboxes(timepointlist) {
	var timepointcheckboxeshtml = '<div><input type="checkbox" id="SelectAllTimepoints" name="SelectAllTimepoints" ><b>Select All</b><br></div>';	
	count = 0;
	while (count < timepointlist.length)
		{
		timepointcheckboxeshtml += '<div><input type="checkbox" ';
		if (count == 0)
			{
				timepointcheckboxeshtml += ' checked="checked" ';
			}
		timepointcheckboxeshtml += ' id="';
		timepointcheckboxeshtml += timepointlist[count];
		timepointcheckboxeshtml += '" name="';
		timepointcheckboxeshtml += timepointlist[count];
		timepointcheckboxeshtml += '" <b>Day ';
		timepointcheckboxeshtml += timepointlist[count];
		timepointcheckboxeshtml += '</b><br></div>';
		count++;
		}

	return timepointcheckboxeshtml;
}


///////Build CancerType-Treatment Pair (Cohort) Selection Boxes////
///////Build CancerType-Treatment Pair (Cohort) Selection Boxes////
function buildcohortselectionboxes(cancertypetreatmentpairlist, NEWCancerTypeTreatmentShapeColorFormats) {

	var cancertreatpaircheckboxeshtml = '<div><input type="checkbox" id="SelectAllcancertreatpairs" name="SelectAllcancertreatpairs" checked="checked"><b>Select All</b><br></div>';	

	var tempcancertreatpairlist = [];
	var countx = 0;
	while (countx < cancertypetreatmentpairlist.length)
		{
			var temparrayvalue = cancertypetreatmentpairlist[countx];
			tempcancertreatpairlist.push(temparrayvalue);
			countx++;
		}
	var sortedcancertreatpairlist = tempcancertreatpairlist.sort();

	var count = 0;
	while (count < sortedcancertreatpairlist.length)
		{
			var selectedpair = sortedcancertreatpairlist[count];
			var positionofspacer = selectedpair.indexOf(" - ");
			var selectedcancertype = selectedpair.substring(0,positionofspacer);
			var selectedtreatment = selectedpair.substring((positionofspacer + 3),selectedpair.length);
			var countY = 0;
			
			while (countY < NEWCancerTypeTreatmentShapeColorFormats.length)
				{
					if (selectedpair == NEWCancerTypeTreatmentShapeColorFormats[countY][0])
						{
							var selectedshapetemp = NEWCancerTypeTreatmentShapeColorFormats[countY][1];
							var selectedcolortemp = NEWCancerTypeTreatmentShapeColorFormats[countY][2];
							
							cancertreatpaircheckboxeshtml += '<div><input type="checkbox" id="';
							cancertreatpaircheckboxeshtml += selectedpair;
							cancertreatpaircheckboxeshtml += '" name="';
							cancertreatpaircheckboxeshtml += selectedpair;
							cancertreatpaircheckboxeshtml += '" <b>';
							cancertreatpaircheckboxeshtml += selectedcancertype;
							cancertreatpaircheckboxeshtml += ' (';
							cancertreatpaircheckboxeshtml += selectedshapetemp;
							cancertreatpaircheckboxeshtml += '): <u style="color: ';
							cancertreatpaircheckboxeshtml += selectedcolortemp;
							cancertreatpaircheckboxeshtml +='">';
							cancertreatpaircheckboxeshtml += selectedtreatment;
							cancertreatpaircheckboxeshtml +='</u></b><br></div>';
							
							var countY = 9999999999;
						}
					countY++;
				}
			count++;
		}
	
	return cancertreatpaircheckboxeshtml;
}


/////Build Parameter Selection Boxes for OUTCOMES ANALYSIS/////	
/////Build Parameter Selection Boxes for OUTCOMES ANALYSIS/////	
function buildparameterselectionboxes(populationlist) {	
	var parametercheckboxeshtml = '<div><input type="checkbox" id="SelectAllParameters" name="SelectAllParameters" ><b>Select All</b><br></div>';	

	var sortedpopulationlist = populationlist;

	var count = 0;
	while (count < sortedpopulationlist.length)
		{
		parametercheckboxeshtml += '<div><input type="checkbox" id="';
		parametercheckboxeshtml += sortedpopulationlist[count];
		parametercheckboxeshtml += '" name="';
		parametercheckboxeshtml += sortedpopulationlist[count];
		parametercheckboxeshtml += '" ';
		if (count == 0)
			{
				parametercheckboxeshtml += 'checked="checked" ';
			}
		parametercheckboxeshtml += '<b>';
		parametercheckboxeshtml += sortedpopulationlist[count];
		parametercheckboxeshtml += '</b><br></div>';
		count++;
		}
	
	return parametercheckboxeshtml;
}



//////Build parameter + outcomes selection boxes for COLUMN CHART////////////////
//////Build parameter + outcomes selection boxes for COLUMN CHART////////////////
function buildparameterselectionboxesCOLUMN(populationlist, outcomeslist) {
	var parametercheckboxeshtml = '<div><input type="checkbox" id="SelectAllParameters" name="SelectAllParameters" ><b>Select All</b><br></div>';	

	var sortedpopulationlist = populationlist;

	var count = 0;
	while (count < sortedpopulationlist.length)
		{
		parametercheckboxeshtml += '<div><input type="checkbox" id="';
		parametercheckboxeshtml += sortedpopulationlist[count];
		parametercheckboxeshtml += '" name="';
		parametercheckboxeshtml += sortedpopulationlist[count];
		parametercheckboxeshtml += '" ';
		if (count == 0)
			{
				parametercheckboxeshtml += 'checked="checked" ';
			}
		parametercheckboxeshtml += '<b>';
		parametercheckboxeshtml += sortedpopulationlist[count];
		parametercheckboxeshtml += '</b><br></div>';
		count++;
		}

	var count = 0;
	while (count < outcomeslist.length)
		{
		parametercheckboxeshtml += '<div style="display:none"><input type="checkbox" id="';
		parametercheckboxeshtml += outcomeslist[count];
		parametercheckboxeshtml += '" name="';
		parametercheckboxeshtml += outcomeslist[count];
		parametercheckboxeshtml += '" ';
		parametercheckboxeshtml += '<b>';
		parametercheckboxeshtml += outcomeslist[count];
		parametercheckboxeshtml += '</b><br></div>';
		count++;
		}

	
	return parametercheckboxeshtml;
}



/////Build Group Selection Boxes for OUTCOMES CHART////
/////Build Group Selection Boxes for OUTCOMES CHART////
function buildgroupselectionboxes(groupsubsetuniquelist) {

	var groupscheckboxeshtml = '<div><input type="checkbox" id="SelectAllGroups" name="SelectAllGroups" checked="checked"><b>Select All</b><br></div>';	

	var tempgroupsubsetlist = [];
	var countx = 0;
	while (countx < groupsubsetuniquelist.length)
		{
			var temparrayvalue = groupsubsetuniquelist[countx];
			tempgroupsubsetlist.push(temparrayvalue);
			countx++;
		}
	var sortedgroupsubsetuniquelist = tempgroupsubsetlist.sort();

	var count = 0;
	while (count < sortedgroupsubsetuniquelist.length)
		{
			var selectedgroup = sortedgroupsubsetuniquelist[count];
			var simpleselectedgroup = selectedgroup.substring(8,selectedgroup.length);

			groupscheckboxeshtml += '<div><input type="checkbox" id="';
			groupscheckboxeshtml += selectedgroup;
			groupscheckboxeshtml += '" name="';
			groupscheckboxeshtml += selectedgroup;
			groupscheckboxeshtml += '" <b>';
			groupscheckboxeshtml += simpleselectedgroup;
			groupscheckboxeshtml += '</b><br></div>';
			count++;
		}
	
	return groupscheckboxeshtml;
}


/////Build Group Selection Boxes for COLUMN CHART////
/////Build Group Selection Boxes for COLUMN CHART////
function buildgroupselectionboxesCOLUMN(groupsubsetuniquelist) {

	var groupscheckboxeshtml = '<div><input type="checkbox" id="TotalGroups" name="TotalGroups" checked="checked"><b>Total {No Filter}</b><br></div>';	

	var tempgroupsubsetlist = [];
	var countx = 0;
	while (countx < groupsubsetuniquelist.length)
		{
			var temparrayvalue = groupsubsetuniquelist[countx];
			tempgroupsubsetlist.push(temparrayvalue);
			countx++;
		}
	var sortedgroupsubsetuniquelist = tempgroupsubsetlist.sort();

	var count = 0;
	while (count < sortedgroupsubsetuniquelist.length)
		{
			var selectedgroup = sortedgroupsubsetuniquelist[count];
			var simpleselectedgroup = selectedgroup.substring(8,selectedgroup.length);

			groupscheckboxeshtml += '<div><input type="checkbox" id="';
			groupscheckboxeshtml += selectedgroup;
			groupscheckboxeshtml += '" name="';
			groupscheckboxeshtml += selectedgroup;
			groupscheckboxeshtml += '" <b>';
			groupscheckboxeshtml += simpleselectedgroup;
			groupscheckboxeshtml += '</b><br></div>';
			count++;
		}
	
	return groupscheckboxeshtml;
}



////Populate Selection Boxes////////
////Populate Selection Boxes////////
	function populateselectionboxes(outcomescheckboxeshtml, timepointcheckboxeshtml, cancertreatpaircheckboxeshtml, parametercheckboxeshtml, groupscheckboxeshtml) {
		$("#outcomes").html(outcomescheckboxeshtml);
		$("#timepoints").html(timepointcheckboxeshtml);
		$("#cancertypetreatmentpair").html(cancertreatpaircheckboxeshtml);
		$("#parameters").html(parametercheckboxeshtml);
		$("#groups").html(groupscheckboxeshtml);
	}






////////Functions for Processing Data for Statistical Analyses and Defining Relationships/////////////////////////////////////////////////////////////////////////////////
////////Functions for Processing Data for Statistical Analyses and Defining Relationships/////////////////////////////////////////////////////////////////////////////////
////////Functions for Processing Data for Statistical Analyses and Defining Relationships/////////////////////////////////////////////////////////////////////////////////
////////Functions for Processing Data for Statistical Analyses and Defining Relationships/////////////////////////////////////////////////////////////////////////////////

//////Construct Lists of Outcomes and Parameters with Position in MasterOutcomesArray Values///////
//////Construct Lists of Outcomes and Parameters with Position in MasterOutcomesArray Values///////
function defineoutcomeandparameterLABELSandPOSITIONS(MasterOutcomesArray) {	
	var MasterArrayparameterpositions = [];
	var MasterArrayparameterlabels = [];

	var MasterArrayoutcomepositions = [];
	var MasterArrayoutcomelabels = [];

	var count = 0;
	while (count < MasterOutcomesArray[0].length)
		{
			var selectedcolumn = MasterOutcomesArray[0][count];
			if (selectedcolumn.indexOf("Outcomes -") > -1)
				{
					MasterArrayoutcomepositions.push(count);
					MasterArrayoutcomelabels.push(selectedcolumn);
				}
			if (selectedcolumn.indexOf(": ") > -1)
				{
					MasterArrayparameterpositions.push(count);
					MasterArrayparameterlabels.push(selectedcolumn);
				}				
			count++;
		}
	
	var outcomesandparametersLABELSandPOSITIONS = [MasterArrayoutcomelabels, MasterArrayoutcomepositions, MasterArrayparameterlabels, MasterArrayparameterpositions];
	
	return outcomesandparametersLABELSandPOSITIONS;
}


///////Create Arrays for Linear Regression TOTAL RELATIONSHIPS for OUTCOMES ANALYSIS////////
///////Create Arrays for Linear Regression TOTAL RELATIONSHIPS for OUTCOMES ANALYSIS////////
function createarraysforlinearregressionTOTALRELATIONSHIPS(MasterArrayoutcomelabels, MasterArrayoutcomepositions, MasterArrayparameterlabels, MasterArrayparameterpositions, MasterOutcomesArray) {
	var lrArray = [];
	var r2list = [];
	var SelectedOutcome = "undefined";
	var SelectedPopulation = "undefined";
	var SelectedParameter2 = "none";
	var SelectedGroup = "ALL";
	var SelectedCohort = "ALL";

	var OutcomesCount = 0;
	while (OutcomesCount < MasterArrayoutcomelabels.length)
		{
			var SelectedOutcome = MasterArrayoutcomelabels[OutcomesCount];
			var SelectedOutcomePosition = MasterArrayoutcomepositions[OutcomesCount];
			
			var PopulationsCount = 0;
			while (PopulationsCount < MasterArrayparameterlabels.length)
				{
					var SelectedPopulation = MasterArrayparameterlabels[PopulationsCount];
					var SelectedPopulationPosition = MasterArrayparameterpositions[PopulationsCount];			
					
						var XaxisOutcome = [];
						var YaxisParameter = [];
						var Information = [];
						var MasterCount = 1;

						while (MasterCount < MasterOutcomesArray.length)
							{
								var SelectedOutcomeValue = MasterOutcomesArray[MasterCount][SelectedOutcomePosition];
								var SelectedPopulationValue = MasterOutcomesArray[MasterCount][SelectedPopulationPosition];
								
								
								if ((SelectedOutcomeValue !== null) && (SelectedPopulationValue !== null))
									{
										var PatientID = MasterOutcomesArray[MasterCount][0];
										XaxisOutcome.push(SelectedOutcomeValue);
										YaxisParameter.push(SelectedPopulationValue);
										Information.push([PatientID, SelectedOutcome, SelectedPopulation]);
									}
								MasterCount++; 
							}
						
						if (XaxisOutcome.length > 7)
							{	
								
								var CorrelationInputArray = calculatelinearregressionandpvalue(XaxisOutcome, YaxisParameter, SelectedOutcome, SelectedPopulation);
								CorrelationInputArray.push(SelectedOutcome, SelectedPopulation, SelectedParameter2, SelectedGroup, SelectedCohort);
								lrArray.push(CorrelationInputArray);				
							}
							
					PopulationsCount++;
				}
			OutcomesCount++;
		}
	//Sort and display r2 values
	lrArray.sort(function(a,b){
		return a[0] - b[0];
	});

	
	return lrArray;
}


/////////Create Arrays for Linear Regression Analysis of COHORT RELATIONSHIPS for OUTCOMES ANALYSIS//////////////////
/////////Create Arrays for Linear Regression Analysis of COHORT RELATIONSHIPS for OUTCOMES ANALYSIS//////////////////
function createarraysforlinearregressionCOHORTRELATIONSHIPS(MasterArrayoutcomelabels, MasterArrayoutcomepositions, MasterArrayparameterlabels, MasterArrayparameterpositions, cancertypetreatpairrowsarray, MasterOutcomesArray) {	
	var cohortlrArray = [];
	var cohortr2list = [];
	var SelectedOutcome = "undefined";
	var SelectedPopulation = "undefined";
	var SelectedParameter2 = "none";
	var SelectedGroup = "ALL";
	var SelectedCohort = "ALL";
	var OutcomesCount = 0;
	while (OutcomesCount < MasterArrayoutcomelabels.length)
		{
			var SelectedOutcome = MasterArrayoutcomelabels[OutcomesCount];
			var SelectedOutcomePosition = MasterArrayoutcomepositions[OutcomesCount];
			
			
			var PopulationsCount = 0;
			while (PopulationsCount < MasterArrayparameterlabels.length)
				{
					
					var SelectedPopulation = MasterArrayparameterlabels[PopulationsCount];
					var SelectedPopulationPosition = MasterArrayparameterpositions[PopulationsCount];			
					
						var MasterCount = 0;
						while (MasterCount < cancertypetreatpairrowsarray.length)
							{
								var tempcohort = cancertypetreatpairrowsarray[MasterCount][0];
								var SelectedCohort = tempcohort;
								var temprowarray = cancertypetreatpairrowsarray[MasterCount][2];
								var XaxisOutcome = [];
								var YaxisParameter = [];
								var Information = [];
								
								var RowCount = 0;
								while (RowCount < temprowarray.length)
									{
										var temprowvalue = temprowarray[RowCount];
										
										var SelectedPopulationValue = MasterOutcomesArray[temprowvalue][SelectedPopulationPosition];
										var SelectedOutcomeValue = MasterOutcomesArray[temprowvalue][SelectedOutcomePosition];	
								
										if ((SelectedOutcomeValue !== null && isNaN(SelectedOutcomeValue) == false) && (SelectedPopulationValue !== null && isNaN(SelectedPopulationValue) == false))
											{
												var PatientID = MasterOutcomesArray[temprowvalue][0];
												XaxisOutcome.push(SelectedOutcomeValue);
												YaxisParameter.push(SelectedPopulationValue);
												Information.push([PatientID, SelectedOutcome, SelectedPopulation]);
											}
										RowCount++; 
									}
						
								if (XaxisOutcome.length > 7)
									{
										var CorrelationInputArray = calculatelinearregressionandpvalue(XaxisOutcome, YaxisParameter, SelectedOutcome, SelectedPopulation);
										CorrelationInputArray.push(SelectedOutcome, SelectedPopulation, SelectedParameter2, SelectedGroup, SelectedCohort);
										cohortlrArray.push(CorrelationInputArray);
									}
								MasterCount++;
							}
					PopulationsCount++;
				}
			OutcomesCount++;
		}
		

		//Sort and display r2 values//
		cohortlrArray.sort(function(a,b){
			return a[0] - b[0];
		});
		
		
		return cohortlrArray;
	}
	
	

///////Create Arrays for Linear Regression Analysis of GROUP RELATIONSHIPS for OUTCOMES ANALYSIS//////////////
///////Create Arrays for Linear Regression Analysis of GROUP RELATIONSHIPS for OUTCOMES ANALYSIS//////////////
function createarraysforlinearregressionGROUPRELATIONSHIPS(MasterArrayoutcomelabels, MasterArrayoutcomepositions, MasterArrayparameterlabels, MasterArrayparameterpositions, mergedgroupsubsetpairnamesandrows, MasterOutcomesArray) {	
		
	var lrArray = [];
	var r2list = [];
	var SelectedOutcome = "undefined";
	var SelectedPopulation = "undefined";
	var SelectedParameter2 = "none";
	var SelectedGroup = "ALL";
	var SelectedCohort = "ALL";

	var OutcomesCount = 0;
	while (OutcomesCount < MasterArrayoutcomelabels.length)
		{
			var SelectedOutcome = MasterArrayoutcomelabels[OutcomesCount];
			var SelectedOutcomePosition = MasterArrayoutcomepositions[OutcomesCount];
			
			
			var PopulationsCount = 0;
			while (PopulationsCount < MasterArrayparameterlabels.length)
				{
					var SelectedPopulation = MasterArrayparameterlabels[PopulationsCount];
					var SelectedPopulationPosition = MasterArrayparameterpositions[PopulationsCount];			
						
						var MasterCount = 0;
						while (MasterCount < mergedgroupsubsetpairnamesandrows.length)
							{
								
								var tempgroup = mergedgroupsubsetpairnamesandrows[MasterCount][0];
								var SelectedGroup = tempgroup;
								var temprowarray = mergedgroupsubsetpairnamesandrows[MasterCount][1];
								var XaxisOutcome = [];
								var YaxisParameter = [];
								var Information = [];
								
								var RowCount = 0;
								while (RowCount < temprowarray.length)
									{
										
										var temprowvalue = temprowarray[RowCount];
										var SelectedOutcomeValue = MasterOutcomesArray[temprowvalue][SelectedOutcomePosition];
										var SelectedPopulationValue = MasterOutcomesArray[temprowvalue][SelectedPopulationPosition];	
								
										if ((SelectedOutcomeValue !== null && isNaN(SelectedOutcomeValue) == false) && (SelectedPopulationValue !== null && isNaN(SelectedPopulationValue) == false))
											{
												var PatientID = MasterOutcomesArray[temprowvalue][0];
												XaxisOutcome.push(SelectedOutcomeValue);
												YaxisParameter.push(SelectedPopulationValue);
												Information.push([PatientID, SelectedOutcome, SelectedPopulation]);
											}
										RowCount++; 
									}
						
								if (XaxisOutcome.length > 7)
									{
										
										var CorrelationInputArray = calculatelinearregressionandpvalue(XaxisOutcome, YaxisParameter, SelectedOutcome, SelectedPopulation);
										CorrelationInputArray.push(SelectedOutcome, SelectedPopulation, SelectedParameter2, SelectedGroup, SelectedCohort);
										lrArray.push(CorrelationInputArray);
									}
								MasterCount++;
							}
					PopulationsCount++;
				}
			OutcomesCount++;
		}
		
	//Sort and display r2 values
	lrArray.sort(function(a,b){
		return a[0] - b[0];
	});
	
	return lrArray;
}


///////Create Arrays for Linear Regression Analysis of COHORT-GROUP RELATIONSHIPS for OUTCOMES ANALYSIS//////////////
///////Create Arrays for Linear Regression Analysis of COHORT-GROUP RELATIONSHIPS for OUTCOMES ANALYSIS//////////////
function createarraysforlinearregressionCOHORTGROUPRELATIONSHIPS(MasterArrayoutcomelabels, MasterArrayoutcomepositions, MasterArrayparameterlabels, MasterArrayparameterpositions, cohortgrouppairsandrows, MasterOutcomesArray) {	
	
	var lrArray = [];
	var r2list = [];
	var SelectedOutcome = "undefined";
	var SelectedPopulation = "undefined";
	var SelectedParameter2 = "none";
	var SelectedGroup = "ALL";
	var SelectedCohort = "ALL";

	var OutcomesCount = 0;
	while (OutcomesCount < MasterArrayoutcomelabels.length)
		{
			var SelectedOutcome = MasterArrayoutcomelabels[OutcomesCount];
			var SelectedOutcomePosition = MasterArrayoutcomepositions[OutcomesCount];
			
			
			var PopulationsCount = 0;
			while (PopulationsCount < MasterArrayparameterlabels.length)
				{
					var SelectedPopulation = MasterArrayparameterlabels[PopulationsCount];
					var SelectedPopulationPosition = MasterArrayparameterpositions[PopulationsCount];			
						
						var MasterCount = 0;
						while (MasterCount < cohortgrouppairsandrows.length)
							{
								
								var XaxisOutcome = [];
								var YaxisParameter = [];
								var Information = [];
								var tempcohort = cohortgrouppairsandrows[MasterCount][0];
								var SelectedCohort = tempcohort;
								var tempgroup = cohortgrouppairsandrows[MasterCount][1];
								var SelectedGroup = tempgroup;
								var temprowarray = cohortgrouppairsandrows[MasterCount][2];
								
								var RowCount = 0;
								while (RowCount < temprowarray.length)
									{
										var temprowvalue = temprowarray[RowCount];
										var SelectedOutcomeValue = MasterOutcomesArray[temprowvalue][SelectedOutcomePosition];
										var SelectedPopulationValue = MasterOutcomesArray[temprowvalue][SelectedPopulationPosition];	
								
										if ((SelectedOutcomeValue !== null && isNaN(SelectedOutcomeValue) == false) && (SelectedPopulationValue !== null && isNaN(SelectedPopulationValue) == false))
											{
												var PatientID = MasterOutcomesArray[temprowvalue][0];
												XaxisOutcome.push(SelectedOutcomeValue);
												YaxisParameter.push(SelectedPopulationValue);
												Information.push([PatientID, SelectedOutcome, SelectedPopulation]);
											}
										RowCount++; 
									}
						
								if (XaxisOutcome.length > 7)
									{
										var CorrelationInputArray = calculatelinearregressionandpvalue(XaxisOutcome, YaxisParameter, SelectedOutcome, SelectedPopulation);
										CorrelationInputArray.push(SelectedOutcome, SelectedPopulation, SelectedParameter2, SelectedGroup, SelectedCohort);
										lrArray.push(CorrelationInputArray);
									}
								MasterCount++;
							}
					PopulationsCount++;
				}
			OutcomesCount++;
		}
			

	//Sort and display r2 values
	lrArray.sort(function(a,b){
		return a[0] - b[0];
	});
	
	return lrArray;
}


////Organize Relationships and Populate DIVs//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////Organize Relationships and Populate DIVs//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////Organize Relationships and Populate DIVs//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////Organize Relationships and Populate DIVs//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////Organize Relationships and Populate DIVs//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////Organize Basic (Total) Relationships and Create Div HTML for OUTCOMES ANALYSIS///////
///////Organize Basic (Total) Relationships and Create Div HTML for OUTCOMES ANALYSIS///////
function organizeTOTALRELATIONSHIPS(lrArray) {

	//r2 values Relationship Boxes and Array
	var relationshipscompletearray = [];
	relationshipscompletearray.push(["P VALUE","R2","R2 {adjusted}","SLOPE","INTERCEPT","SAMPLE SIZE","OUTCOME","PARAMETER1","PARAMETER2","GROUP","COHORT"]);

	var relationshipshtml = "<div>";	
	count = 0;
	while (count < lrArray.length)
		{
		var temppvalue = lrArray[count][0];
		var tempr2 = lrArray[count][1];
		var temp4r2 = lrArray[count][2];
		var tempslope = lrArray[count][3];
		var tempintercept = lrArray[count][4];
		var tempsamplesize = lrArray[count][5];
		var tempoutcome = lrArray[count][6];
		var tempparameter1 = lrArray[count][7];
		var tempparameter2 = lrArray[count][8];
		var tempgroup = lrArray[count][9];
		var tempcohort = lrArray[count][10];
		relationshipscompletearray.push([temppvalue,tempr2,temp4r2,tempslope,tempintercept,tempsamplesize,tempoutcome,tempparameter1,tempparameter2,tempgroup,tempcohort]);
		
		if (count < 400) {
			relationshipshtml += '<b>P Value: ';
			relationshipshtml += temppvalue;
			relationshipshtml += '</b>, r2: ';
			relationshipshtml += tempr2;
			relationshipshtml += ', r2 {adj}: ';
			relationshipshtml += temp4r2;
			relationshipshtml += '<br><b>Timepoint-Parameter: </b><u> Day ';
			relationshipshtml += tempparameter1;
			relationshipshtml += '</u><br><b>Outcome: </b><u>';
			relationshipshtml += tempoutcome;
			relationshipshtml += '</u><br><br>';
			}
		
		count++;
		}
	relationshipshtml += '</div>';

	var TOTALRELATIONSHIPSINFO = [relationshipscompletearray, relationshipshtml];
	
	return TOTALRELATIONSHIPSINFO;
}


////Organize Cohort Relationships and create DIV HTML for OUTCOMES ANALYSIS/////
////Organize Cohort Relationships and create DIV HTML for OUTCOMES ANALYSIS/////
function organizeCOHORTRELATIONSHIPS(RAWcohortlrArray) {
	
	//////r2 values Relationship Boxes and Array////////
	var cohortrelationshipscompletearray = [];
	cohortrelationshipscompletearray.push(["P VALUE","R2","R2 {adjusted}","SLOPE","INTERCEPT","SAMPLE SIZE","OUTCOME","PARAMETER1","PARAMETER2","GROUP","COHORT"]);

	var cohortrelationshipshtml = "<div>";	
	count = 0;
	while (count < RAWcohortlrArray.length)
		{
		var temppvalue = RAWcohortlrArray[count][0];
		var tempr2 = RAWcohortlrArray[count][1];
		var temp4r2 = RAWcohortlrArray[count][2];
		var tempslope = RAWcohortlrArray[count][3];
		var tempintercept = RAWcohortlrArray[count][4];
		var tempsamplesize = RAWcohortlrArray[count][5];
		var tempoutcome = RAWcohortlrArray[count][6];
		var tempparameter1 = RAWcohortlrArray[count][7];
		var tempparameter2 = RAWcohortlrArray[count][8];
		var tempgroup = RAWcohortlrArray[count][9];
		var tempcohort = RAWcohortlrArray[count][10];
		cohortrelationshipscompletearray.push([temppvalue,tempr2,temp4r2,tempslope,tempintercept,tempsamplesize,tempoutcome,tempparameter1,tempparameter2,tempgroup,tempcohort]);

		if (count < 400) {
			cohortrelationshipshtml += '<b>P Value: ';
			cohortrelationshipshtml += temppvalue;
			cohortrelationshipshtml += '</b>, r2: ';
			cohortrelationshipshtml += tempr2;
			cohortrelationshipshtml += ', r2 {adj}: ';
			cohortrelationshipshtml += temp4r2;
			cohortrelationshipshtml += '<br><b>Timepoint-Parameter: </b><u>Day ';
			cohortrelationshipshtml += tempparameter1;
			cohortrelationshipshtml += '</u><br><b>Outcome: </b><u>';
			cohortrelationshipshtml += tempoutcome;
			cohortrelationshipshtml += '</u><br><b>Cohort: </b>';
			cohortrelationshipshtml += tempcohort;
			cohortrelationshipshtml += '<br><br>';
		}

		count++;
		}
	cohortrelationshipshtml += '</div>';
	
	var COHORTRELATIONSHIPSINFO = [cohortrelationshipscompletearray, cohortrelationshipshtml];
	
	return COHORTRELATIONSHIPSINFO;
}


///////Organize GROUP Relationships and Create Div HTML for OUTCOMES ANALYSIS///////
///////Organize GROUP Relationships and Create Div HTML for OUTCOMES ANALYSIS///////
function organizeGROUPRELATIONSHIPS(lrArray) {
	//////r2 values Relationship Boxes and Array////////
	var grouprelationshipscompletearray = [];
	grouprelationshipscompletearray.push(["P VALUE","R2","R2 {adjusted}","SLOPE","INTERCEPT","SAMPLE SIZE","OUTCOME","PARAMETER1","PARAMETER2","GROUP","COHORT"]);

	var grouprelationshipshtml = "<div>";	
	count = 0;
	while (count < lrArray.length)
		{
		var tempPvalue = lrArray[count][0];
		var tempr2 = lrArray[count][1];
		var temp4r2 = lrArray[count][2];
		var tempslope = lrArray[count][3];
		var tempintercept = lrArray[count][4];
		var tempsamplesize = lrArray[count][5];
		var tempoutcome = lrArray[count][6];
		var tempparameter1 = lrArray[count][7];
		var tempparameter2 = lrArray[count][8];
		var tempgroup = lrArray[count][9];
		var tempcohort = lrArray[count][10];
		grouprelationshipscompletearray.push([tempPvalue,tempr2,temp4r2,tempslope,tempintercept,tempsamplesize,tempoutcome,tempparameter1,tempparameter2,tempgroup,tempcohort]);
		
		if (count < 400) {
			grouprelationshipshtml += '<b>P Value: ';
			grouprelationshipshtml += tempPvalue;
			grouprelationshipshtml += '</b>, r2: ';
			grouprelationshipshtml += tempr2;
			grouprelationshipshtml += ', r2 {adj}: ';
			grouprelationshipshtml += temp4r2;
			grouprelationshipshtml += '<br><b>Timepoint-Parameter: </b><u>Day ';
			grouprelationshipshtml += tempparameter1;
			grouprelationshipshtml += '</u><br><b>Outcome: </b><u>';
			grouprelationshipshtml += tempoutcome;
			grouprelationshipshtml += '</u><br><b>Group: </b>';
			grouprelationshipshtml += tempgroup;
			grouprelationshipshtml += '<br><br>';
		}
		
		count++;
		}
	grouprelationshipshtml += '</div>';

	var GROUPRELATIONSHIPSINFO = [grouprelationshipscompletearray, grouprelationshipshtml];
	
	return GROUPRELATIONSHIPSINFO;
}


///////Organize COHORT-GROUP Relationships and Create Div HTML for OUTCOMES ANALYSIS///////
///////Organize COHORT-GROUP Relationships and Create Div HTML for OUTCOMES ANALYSIS///////
function organizeCOHORTGROUPRELATIONSHIPS(lrArray) {
	//////r2 values Relationship Boxes and Array////////
	var cohortgrouprelationshipscompletearray = [];
	cohortgrouprelationshipscompletearray.push(["P VALUE","R2","R2 {adjusted}","SLOPE","INTERCEPT","SAMPLE SIZE","OUTCOME","PARAMETER1","PARAMETER2","GROUP","COHORT"]);

	var cohortgrouprelationshipshtml = "<div>";	
	count = 0;
	while (count < lrArray.length)
		{
		var tempPvalue = lrArray[count][0];
		var tempr2 = lrArray[count][1];
		var temp4r2 = lrArray[count][2];
		var tempslope = lrArray[count][3];
		var tempintercept = lrArray[count][4];
		var tempsamplesize = lrArray[count][5];
		var tempoutcome = lrArray[count][6];
		var tempparameter1 = lrArray[count][7];
		var tempparameter2 = lrArray[count][8];
		var tempgroup = lrArray[count][9];
		var tempcohort = lrArray[count][10];
		cohortgrouprelationshipscompletearray.push([tempPvalue,tempr2,temp4r2,tempslope,tempintercept,tempsamplesize,tempoutcome,tempparameter1,tempparameter2,tempgroup,tempcohort]);
		
		if (count < 400) {
			cohortgrouprelationshipshtml += '<b>P Value: ';
			cohortgrouprelationshipshtml += tempPvalue;
			cohortgrouprelationshipshtml += '</b>, r2: ';
			cohortgrouprelationshipshtml += tempr2;
			cohortgrouprelationshipshtml += ', r2 {adj}: ';
			cohortgrouprelationshipshtml += temp4r2;
			cohortgrouprelationshipshtml += '<br><b>Timepoint-Parameter: </b><u>Day ';
			cohortgrouprelationshipshtml += tempparameter1;
			cohortgrouprelationshipshtml += '</u><br><b>Outcome: </b><u>';
			cohortgrouprelationshipshtml += tempoutcome;
			cohortgrouprelationshipshtml += '</u><br><b>Cohort: </b>';
			cohortgrouprelationshipshtml += tempcohort;
			cohortgrouprelationshipshtml += '<br><b>Group: </b>';
			cohortgrouprelationshipshtml += tempgroup;
			cohortgrouprelationshipshtml += '<br><br>';
		}
		
		count++;
		}
	cohortgrouprelationshipshtml += '</div>';

	var COHORTGROUPRELATIONSHIPSINFO = [cohortgrouprelationshipscompletearray, cohortgrouprelationshipshtml];
	
	return COHORTGROUPRELATIONSHIPSINFO;
}


/////Function to Construct Merged Group ANOVA Report for COLUMN CHART/////////////////////////////
/////Function to Construct Merged Group ANOVA Report for COLUMN CHART/////////////////////////////
function constructMergedGroupANOVAhtml(MergedGroupsANOVA) {

	if (MergedGroupsANOVA !== null && MergedGroupsANOVA.length > 2)
		{
			var ANOVAhtml = "<div>";	
			var count = 0;
			while (count < MergedGroupsANOVA.length)
				{
					var tempPvalue = MergedGroupsANOVA[count][0];
					var tempFscore = MergedGroupsANOVA[count][1];
					var tempmaxdifference = MergedGroupsANOVA[count][2];
					var temptimepoint = MergedGroupsANOVA[count][3];
					var temptreatment = MergedGroupsANOVA[count][4];
					var tempparameter = MergedGroupsANOVA[count][5];
					var tempgroup = MergedGroupsANOVA[count][6];
					if (tempPvalue > -1)
						{	
							if (count < 400)
								{
									ANOVAhtml += "<b>P Value: ";
									ANOVAhtml += tempPvalue;
									ANOVAhtml += "</b>, Max Diff: ";
									ANOVAhtml += tempmaxdifference;
									ANOVAhtml += " <br><b>Timepoint:</b> Day ";
									ANOVAhtml += temptimepoint;
									ANOVAhtml += "<br><b>Parameter:</b> ";
									ANOVAhtml += tempparameter;
									ANOVAhtml += "<br><b>Treatment:</b> ";
									ANOVAhtml += temptreatment;
									ANOVAhtml += "<br><b>Parent Group: </b>";
									ANOVAhtml += tempgroup;
									ANOVAhtml += "<br><b>Cohort:</b> Composite<br><br>";
								}
						}
					count++;
				}
			ANOVAhtml += "</div>";
		}
		
	else 
		{
			ANOVAhtml = "<div>There are no parent groups with at least three sub-groups in this data set. Or there has been an error.</div>";
		}

	return ANOVAhtml;
}


//////////Function to Construct Group T Test Relationships HTML for COLUMN CHART/////////////////////////////
//////////Function to Construct Group T Test Relationships HTML for COLUMN CHART/////////////////////////////
//////////Function to Construct Group T Test Relationships HTML for COLUMN CHART/////////////////////////////
///individualTTestArray -> [[PValue, TScore, combinedarraylistlegend[count2], combinedarraylistlegend[count], difference, targetmean, referencemean, temptimepoint, temptreatment, tempparameter]];
function constructMergedGroupTTesthtml(MergedGroupsTTest) {

	if (MergedGroupsTTest !== null && MergedGroupsTTest.length > 2)
		{
			var ANOVAhtml = "<div>";	
			var count = 0;
			while (count < MergedGroupsTTest.length)
				{
					var tempPvalue = MergedGroupsTTest[count][0];
					var tempTscore = MergedGroupsTTest[count][1];
					var tempTargetGroup = MergedGroupsTTest[count][2];
					var tempReferenceGroup = MergedGroupsTTest[count][3];
					var tempmaxdifference = MergedGroupsTTest[count][4];
					var tempTargetMean = MergedGroupsTTest[count][5];
					var tempReferenceMean = MergedGroupsTTest[count][6];
					var temptimepoint = MergedGroupsTTest[count][7];
					var temptreatment = MergedGroupsTTest[count][8];
					var tempparameter = MergedGroupsTTest[count][9];
					if (tempPvalue > -1)
						{	
							if (count < 400)
								{
									ANOVAhtml += "<b>P Value: ";
									ANOVAhtml += tempPvalue;
									ANOVAhtml += "</b>, Max Diff: ";
									ANOVAhtml += tempmaxdifference;
									ANOVAhtml += " <br><b>Timepoint:</b> Day ";
									ANOVAhtml += temptimepoint;
									ANOVAhtml += "<br><b>Parameter:</b> ";
									ANOVAhtml += tempparameter;
									ANOVAhtml += "<br><b>Treatment:</b> ";
									ANOVAhtml += temptreatment;
									ANOVAhtml += "<br><b>Reference Group: </b>";
									ANOVAhtml += tempReferenceGroup;
									ANOVAhtml += "<br><b>Target Group: </b>";
									ANOVAhtml += tempTargetGroup;
									ANOVAhtml += "<br><b>Cohort:</b> Composite<br><br>";
								}
						}
					count++;
				}
			ANOVAhtml += "</div>";
		}
		
	else 
		{
			ANOVAhtml = "<div>There are no parent groups with at least two sub-groups in this data set with sufficient information for analysis. Or there has been an error.</div>";
		}

	return ANOVAhtml;
}



////Function to Construct Merged Cohort ANOVA Relationships HTML/////////////////////////////
////Function to Construct Merged Cohort ANOVA Relationships HTML/////////////////////////////
function constructMergedCohortANOVAhtml(MergedCohortsANOVA) {

	if (MergedCohortsANOVA !== null && MergedCohortsANOVA.length > 2)
		{
			var ANOVAhtml = "<div>";	
			var count = 0;
			while (count < MergedCohortsANOVA.length)
				{
					var tempPvalue = MergedCohortsANOVA[count][0];
					var tempFscore = MergedCohortsANOVA[count][1];
					var tempmaxdifference = MergedCohortsANOVA[count][2];
					var temptimepoint = MergedCohortsANOVA[count][3];
					var temptreatment = MergedCohortsANOVA[count][4];
					var tempparameter = MergedCohortsANOVA[count][5];
					var tempgroup = MergedCohortsANOVA[count][6];
					if (tempPvalue > -1)
						{	
							if (count < 400)
								{
									ANOVAhtml += "<b>P Value: ";
									ANOVAhtml += tempPvalue;
									ANOVAhtml += "</b>, Max Diff: ";
									ANOVAhtml += tempmaxdifference;
									ANOVAhtml += " <br><b>Timepoint:</b> Day ";
									ANOVAhtml += temptimepoint;
									ANOVAhtml += "<br><b>Parameter:</b> ";
									ANOVAhtml += tempparameter;
									ANOVAhtml += "<br><b>Group:</b> Total<br><br>";
								}
						}
					count++;
				}
			ANOVAhtml += "</div>";
		}

	else 
		{
			ANOVAhtml = "<div>There are fewer than 3 cohorts for all timepint-parameter pairs in this data set. Or there has been an error.</div>";
		}

	return ANOVAhtml;
}


///////////Function to Construct Cohort T-test Analysis Relationships HTML//////////////////////////////////////
///////////Function to Construct Cohort T-test Analysis Relationships HTML//////////////////////////////////////
///individualTTestArray -> [[PValue, TScore, combinedarraylistlegend[count2], combinedarraylistlegend[count], difference, targetmean, referencemean, temptimepoint, temptreatment, tempparameter]];
function constructMergedCohortTTesthtml(MergedCohortsTTest) {

	if (MergedCohortsTTest !== null && MergedCohortsTTest.length > 2)
		{
			var ANOVAhtml = "<div>";	
			var count = 0;
			while (count < MergedCohortsTTest.length)
				{
					var tempPvalue = MergedCohortsTTest[count][0];
					var tempTscore = MergedCohortsTTest[count][1];
					var tempTargetGroup = MergedCohortsTTest[count][2];
					var tempReferenceGroup = MergedCohortsTTest[count][3];
					var tempmaxdifference = MergedCohortsTTest[count][4];
					var tempTargetMean = MergedCohortsTTest[count][5];
					var tempReferenceMean = MergedCohortsTTest[count][6];
					var temptimepoint = MergedCohortsTTest[count][7];
					var temptreatment = MergedCohortsTTest[count][8];
					var tempparameter = MergedCohortsTTest[count][9];
					if (tempPvalue > -1)
						{	
							if (count < 400)
								{
									ANOVAhtml += "<b>P Value: ";
									ANOVAhtml += tempPvalue;
									ANOVAhtml += "</b>, Max Diff: ";
									ANOVAhtml += tempmaxdifference;
									ANOVAhtml += " <br><b>Timepoint:</b> Day ";
									ANOVAhtml += temptimepoint;
									ANOVAhtml += "<br><b>Parameter:</b> ";
									ANOVAhtml += tempparameter;
									ANOVAhtml += "<br><b>Reference Cohort:</b> ";
									ANOVAhtml += tempReferenceGroup;
									ANOVAhtml += "<br><b>Target Cohort:</b> ";
									ANOVAhtml += tempTargetGroup;
									ANOVAhtml += "<br><b>Group:</b> Total<br><br>";
								}
						}
					count++;
				}
			ANOVAhtml += "</div>";
		}

	else 
		{
			ANOVAhtml = "<div>There are fewer than 2 cohorts for all timepoint-parameter pairs in this data set that have sufficient information for analysis. Or there has been an error.</div>";
		}

	return ANOVAhtml;
}







//////////////////Function to Create Merged Treatments ANOVA Analysis Relationships HTML//////////////////////////////////////////////
//////////////////Function to Create Merged Treatments ANOVA Analysis Relationships HTML//////////////////////////////////////////////
function constructMergedTreatmentANOVAhtml(MergedTreatmentsANOVA) {

	if (MergedTreatmentsANOVA !== null && MergedTreatmentsANOVA.length > 2)
		{
			var ANOVAhtml = "<div>";	
			var count = 0;
			while (count < MergedTreatmentsANOVA.length)
				{
					var tempPvalue = MergedTreatmentsANOVA[count][0];
					var tempFscore = MergedTreatmentsANOVA[count][1];
					var tempmaxdifference = MergedTreatmentsANOVA[count][2];
					var temptimepoint = MergedTreatmentsANOVA[count][3];
					var temptreatment = MergedTreatmentsANOVA[count][4];
					var tempparameter = MergedTreatmentsANOVA[count][5];
					var tempgroup = MergedTreatmentsANOVA[count][6];
					if (tempPvalue > -1)
						{	
							if (count < 400)
								{
									ANOVAhtml += "<b>P Value: ";
									ANOVAhtml += tempPvalue;
									ANOVAhtml += "</b>, Max Diff: ";
									ANOVAhtml += tempmaxdifference;
									ANOVAhtml += " <br><b>Timepoint:</b> Day ";
									ANOVAhtml += temptimepoint;
									ANOVAhtml += "<br><b>Parameter:</b> ";
									ANOVAhtml += tempparameter;
									ANOVAhtml += "<br><b>Cohort:</b> Composite<br><br>";
								}
						}
					count++;
				}
			ANOVAhtml += "</div>";
		}

	else 
		{
			ANOVAhtml = "<div>There are fewer than 3 Treatments for all timepoint-parameter pairs in this data set. Or there has been an error.</div>";
		}

	return ANOVAhtml;
}


////Function to Create Treatment T-test Analysis Relationships HTML///////////////////////////////////////////////////////////////////////////
////Function to Create Treatment T-test Analysis Relationships HTML///////////////////////////////////////////////////////////////////////////
///individualTTestArray -> [[PValue, TScore, combinedarraylistlegend[count2], combinedarraylistlegend[count], difference, targetmean, referencemean, temptimepoint, group, tempparameter]];
function constructMergedTreatmentTTesthtml(MergedTreatmentsTTest) {

	if (MergedTreatmentsTTest !== null && MergedTreatmentsTTest.length > 2)
		{
			var TTesthtml = "<div>";	
			var count = 0;
			while (count < MergedTreatmentsTTest.length)
				{
					var tempPvalue = MergedTreatmentsTTest[count][0];
					var tempTscore = MergedTreatmentsTTest[count][1];
					var tempTargetGroup = MergedTreatmentsTTest[count][2];
					var tempReferenceGroup = MergedTreatmentsTTest[count][3];
					var tempmaxdifference = MergedTreatmentsTTest[count][4];
					var temptimepoint = MergedTreatmentsTTest[count][7];
					var tempparameter = MergedTreatmentsTTest[count][9];
					if (tempPvalue > -1)
						{	
							if (count < 400)
								{
									TTesthtml += "<b>P Value: ";
									TTesthtml += tempPvalue;
									TTesthtml += "</b>, Max Diff: ";
									TTesthtml += tempmaxdifference;
									TTesthtml += " <br><b>Timepoint:</b> Day ";
									TTesthtml += temptimepoint;
									TTesthtml += "<br><b>Parameter:</b> ";
									TTesthtml += tempparameter;
									TTesthtml += "<br><b>Reference Treatment:</b> ";
									TTesthtml += tempReferenceGroup;
									TTesthtml += "<br><b>Target Treatment:</b> ";
									TTesthtml += tempTargetGroup;									
									TTesthtml += "<br><b>Cohort:</b> Composite<br><br>";
								}
						}
					count++;
				}
			TTesthtml += "</div>";
		}

	else 
		{
			TTesthtml = "<div>There are fewer than 2 Treatments for all timepoint-parameter pairs in this data set that have sufficient information for analysis. Or there has been an error.</div>";
		}

	return TTesthtml;
}




/////Populate Relationship DIVS////
/////Populate Relationship DIVS////
function populaterelationshipdivs(relationshipshtml, cohortrelationshipshtml, grouprelationshipshtml, cohortgrouprelationshipshtml) {
	
	$("#relationships").html(relationshipshtml);
	$("#cohortrelationships").html(cohortrelationshipshtml);
	$("#grouprelationships").html(grouprelationshipshtml);
	$("#cohortgrouprelationships").html(cohortgrouprelationshipshtml);
}










////////Functions for Relationships Data Export/////////////////////////////////////////////////////////////
////////Functions for Relationships Data Export/////////////////////////////////////////////////////////////
////////Functions for Relationships Data Export/////////////////////////////////////////////////////////////
////////Functions for Relationships Data Export/////////////////////////////////////////////////////////////
////////Functions for Relationships Data Export/////////////////////////////////////////////////////////////


///Export Function///
//////EXPORT DATA SET FUNCTION/////
//////EXPORT DATA SET FUNCTION/////
//////EXPORT DATA SET FUNCTION/////
function downloadFile(fileName, urlData) {

	var aLink = document.createElement('a');
	var evt = document.createEvent("HTMLEvents");
	evt.initEvent("click");
	aLink.download = fileName;
	aLink.href = urlData;
	aLink.dispatchEvent(evt);
};

function exportselecteddataset(dataarray, datalabel) {
		var datastring = "";
		var csvContent = "";
		var exportfilename =  datalabel + ".csv";
		
		if (dataarray.length > 1 && dataarray !== null  && dataarray[0].length > 0)
			{
				var truncatedarray = [];
				var count = 0;
				while (count < dataarray.length && count < 4000)
					{
						truncatedarray.push(dataarray[count]);
						count++;
					}
				
				truncatedarray.forEach(function(infoArray, index){
					dataString = infoArray.join(",");
					csvContent += dataString + "\n";
				});

				var encodedUri = encodeURIComponent(csvContent);
				downloadFile(exportfilename, 'data:text/csv;charset=UTF-8,' + encodedUri);
			}
		else
			{
				alert("There is insufficient data for export.");
			}
}




































//////FUNCTIONS TO DEFINE OPTIONS ON GOOGLE CHARTS/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////FUNCTIONS TO DEFINE OPTIONS ON GOOGLE CHARTS/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////FUNCTIONS TO DEFINE OPTIONS ON GOOGLE CHARTS/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////FUNCTIONS TO DEFINE OPTIONS ON GOOGLE CHARTS/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////FUNCTIONS TO DEFINE OPTIONS ON GOOGLE CHARTS/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


//////Google SCATTER CHART Options Creation//////
//////Google SCATTER CHART Options Creation//////
function defineSCATTERCHARTOPTIONS(SCATTERCHARTtitle, SCATTERCHARTtitleTextStyle, SCATTERCHARTchartArea, SCATTERCHARTpointSize, SCATTERCHARTlegend, SCATTERCHARTvAxisTitle, SCATTERCHARThAxisTitle) {

	var options = {
			  title: SCATTERCHARTtitle,
			  titleTextStyle: SCATTERCHARTtitleTextStyle,
			  chartArea:SCATTERCHARTchartArea,
			  pointSize: SCATTERCHARTpointSize,
			  legend: SCATTERCHARTlegend,
			  interpolateNulls: true,
			  animation: {
				duration: 700,
				},
			  vAxis: {title: SCATTERCHARTvAxisTitle, titleTextStyle: {bold: true, fontSize:16}},
			  hAxis: {title: SCATTERCHARThAxisTitle, titleTextStyle: {bold: true, fontSize:22}},
			  trendlines: {
					0: {pointSize: 2, showR2: true, visibleInLegend: true},
					1: {pointSize: 2, showR2: true, visibleInLegend: true},
					2: {pointSize: 2, showR2: true, visibleInLegend: true},
					3: {pointSize: 2, showR2: true, visibleInLegend: true},
					4: {pointSize: 2, showR2: true, visibleInLegend: true},
					5: {pointSize: 2, showR2: true, visibleInLegend: true},
					6: {pointSize: 2, showR2: true, visibleInLegend: true},
					7: {pointSize: 2, showR2: true, visibleInLegend: true},
					8: {pointSize: 2, showR2: true, visibleInLegend: true},
					9: {pointSize: 2, showR2: true, visibleInLegend: true},
					10: {pointSize: 2, showR2: true, visibleInLegend: true}		
				}
		};
	
	return options;
}


///////UPDATE CHART OPTIONS FOR COLUMN CHART////
///////UPDATE CHART OPTIONS FOR COLUMN CHART////
///////UPDATE CHART OPTIONS FOR COLUMN CHART////
function updateoptionsCOLUMNCHART(MasterTreatmentCohortArrayGOOGLE, ColumnsToShow, RowsToShow, checkedparameters) {
	
	var numberofselectedparameters = checkedparameters.length;
	var numberofcolumns = ColumnsToShow.length;
	var numberofrows = RowsToShow.length;
	if (numberofselectedparameters == 1)
		{
			var HeadTitle = checkedparameters[0];
		}
	else
		{
			var HeadTitle = "Parameter Averages by Cohort";
		}
	
	var updatedfontsize = 15;
	var totalnumberofchartedcolumns = (numberofcolumns - 1);
	var totalnumberofchartedcolumns = (totalnumberofchartedcolumns * numberofrows);
	var totalnumberofchartedcolumns = (totalnumberofchartedcolumns / 5);
	//alert("Total Number of Charted Columns = " + totalnumberofchartedcolumns);
	
	if (numberofselectedparameters > 1 && numberofselectedparameters < 2.1)
		{
			var updatedfontsize = 20;
		}
	if (numberofselectedparameters > 2 && numberofselectedparameters < 4.1)
		{
			var updatedfontsize = 14;
		}		
	if (numberofselectedparameters > 4)
		{
			var updatedfontsize = 9;
		}		
	if (numberofselectedparameters > 6)
		{
			var updatedfontsize = 6;
		}		
	if (numberofselectedparameters > 10)
		{
			var updatedfontsize = 1;
		}	
	
	var seriesoptions = {};
	var seriescount = 0;
	while (seriescount < totalnumberofchartedcolumns)
		{
			var tempselectedcolumn = ColumnsToShow[((seriescount * 5) + 1)]
			var seriescolorvalueSTRING = MasterTreatmentCohortArrayGOOGLE[1][(tempselectedcolumn + 6)];
			var seriescolorvalueOBJECT = {color: seriescolorvalueSTRING};
			if (MasterTreatmentCohortArrayGOOGLE[0][tempselectedcolumn] == "SPACER COLUMN")
				{
					var seriescolorvalueOBJECT = {visibleInLegend: false};
				}
			seriesoptions[seriescount] = seriescolorvalueOBJECT;
			seriescount++;
		}
	
	
	///////Chart Options//////
			var options = {
			  title: HeadTitle,
			  titleTextStyle: {fontSize: 20},
			  chartArea:{width:'65%', left:65, top:60},
			  vAxis: {title: "Parameter Value"},
			  bar: {groupWidth: "62%"},
			  animation:{ duration: 700 },
			  interpolateNulls: false,
			  					
			  annotations: {
					alwaysOutside: true,
					
					textStyle: {
						fontSize: updatedfontsize,
						bold: true,
						opacity: 1,
						
						},
					boxStyle: {
						  // Color of the box outline.
						  stroke: '#888',
						  position: 'top',
						  // Thickness of the box outline.
						  strokeWidth: 1,
						  // x-radius of the corner curvature.
						  rx: 10,
						  // y-radius of the corner curvature.
						  ry: 10,
						  // Attributes for linear gradient fill.
						  gradient: {
							// Start color for gradient.
							color1: '#fbf6a7',
							// Finish color for gradient.
							color2: '#33b679',
							// Where on the boundary to start and
							// end the color1/color2 gradient,
							// relative to the upper left corner
							// of the boundary.
							x1: '0%', y1: '0%',
							x2: '100%', y2: '100%',
							// If true, the boundary for x1,
							// y1, x2, and y2 is the box. If
							// false, it's the entire chart.
							useObjectBoundingBoxUnits: true
						  }
					},
					style: 'point',					
				},
			  series: seriesoptions
			};
			
	return options;
}


//////Determine Updated Chart Titles After Selection for OUTCOMES CHART////
//////Determine Updated Chart Titles After Selection for OUTCOMES CHART////
function determineupdatedcharttitles(ColumnsToShow, MasterOutcomesArray, checkedoutcomes) {

	var vAxisTitle = "Parameter";
	var hAxisTitle = checkedoutcomes[0];
	var charttitle = "Parameters vs " + checkedoutcomes[0];
	var titleTextStyle = {fontSize: 25, bold: true};
	
	if (ColumnsToShow.length == 3)
		{
			var tempcolumnposition = ColumnsToShow[1];
			var tempheader = MasterOutcomesArray[0][tempcolumnposition];
			var firstcolonposition = tempheader.indexOf(":");
			var tempparameter = tempheader.substring((firstcolonposition + 2), tempheader.length);
			var vAxisTitle = tempparameter;
			var charttitle = tempparameter + " vs " + checkedoutcomes[0];	
		}
	
	if (charttitle.length > 40)
		{
			var titleTextStyle = {fontSize: 18, bold: true};
		}

	if (charttitle.length > 85)
		{
			var titleTextStyle = {fontSize: 12, bold: true};
		}
	
	var alltitles = [vAxisTitle, hAxisTitle, charttitle, titleTextStyle];
	
	return alltitles;
}



////Update Selection Info Display for COLUMN CHART///
////Update Selection Info Display for COLUMN CHART///
function updateselectioninfo(SelectedItemRow, SelectedItemColumn, MasterTreatmentCohortArray) {
	var SelectedItemRow = SelectedItemRow + 1;
	var SelectedItemColumnALLVALUES = SelectedItemColumn + 1;
	var samplepopulation = MasterTreatmentCohortArray[0][SelectedItemColumn];
	var samplepopulationsize = MasterTreatmentCohortArray[SelectedItemRow][SelectedItemColumnALLVALUES].length;
	var selectioninfo = "<b>Sample Size:</b> " + samplepopulationsize + ", <b>Cohort:</b> " + samplepopulation;
	$("#selectedpatientinfo").html(selectioninfo);
	}




	/////Define Rows and Coumns to Show for Google COLUMN CHART////////////////////////////////////////////////////////
	/////Define Rows and Coumns to Show for Google COLUMN CHART////////////////////////////////////////////////////////
	function definerowsandcolumnstoshowforcolumnchart(SubsetSelectionFilter, MasterTreatmentCohortArray) {
		var RowsToShow = [];
		
		var checkedtimepoints = SubsetSelectionFilter[0];
		var checkedtreatments = SubsetSelectionFilter[3];
		var checkedgroups = SubsetSelectionFilter[4];
		/////////////////////////////////////////////////////////////////////////////////////////////////////
		///////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////
		var count = 0;
		while (count < MasterTreatmentCohortArray.length)
			{
				var temptimepoint = MasterTreatmentCohortArray[count][0];
				var temptreatment = MasterTreatmentCohortArray[count][1];
				var tempgroup = MasterTreatmentCohortArray[count][2];
				
				var countJ = 0;
				var includetimepoint = -1;
				while (countJ < checkedtimepoints.length)
					{
						var selectedtimepoint = checkedtimepoints[countJ];
						var selectedtimepoint = String(selectedtimepoint);
						if (temptimepoint == selectedtimepoint)
							{
								var includetimepoint = 1;
							}
						countJ++;
					}
				
				var countK = 0;
				var includetreatment = -1;
				while (countK < checkedtreatments.length)
					{
						var selectedtreatment = checkedtreatments[countK];
						var selectedtreatment = String(selectedtreatment);
						if (temptreatment == selectedtreatment)
							{
								var includetreatment = 1;
							}
						countK++;
					}

				var countL = 0;
				var includegroup = -1;
				while (countL < checkedgroups.length)
					{
						var selectedgroup = checkedgroups[countL];
						var selectedgroup = String(selectedgroup);
						if (tempgroup == selectedgroup)
							{
								var includegroup = 1;
							}
						countL++;
					}

				if (includetimepoint == 1 && includetreatment == 1 && includegroup == 1)
					{
						var AdjustedRowPosition = count - 1;
						RowsToShow.push(AdjustedRowPosition);
					}
				count++;
			}
		if (RowsToShow.length < 1)
			{
				alert("I failed to Identify the appropriate rows for selection. You will see the default (no filters).");
				var RowsToShow = 0;
			}

	////Identify Spacer Column Position////////
	var spacercolumnposition = null;
	var count = 0;
	while (count < MasterTreatmentCohortArray[0].length)
		{
			var tempheader = MasterTreatmentCohortArray[0][count];
			if (tempheader == "SPACER COLUMN")
				{
					spacercolumnposition = count;
					var count = 999999999999999999;
				}
			count++;
		}	
	
	/////Define Columns to Show////
		var checkedparameters = SubsetSelectionFilter[1];
		var checkedcohorts = SubsetSelectionFilter[2];
		var ColumnsToShow = [0];
		var PreviousParameter = null;
		var CurrentParameter = "";	
		
		var count = 0;
		while (count < MasterTreatmentCohortArray[0].length)
			{
				var tempheader = MasterTreatmentCohortArray[0][count];
				var colonposition = tempheader.indexOf(":");
				if (colonposition > 0)
					{
						var tempcohort = tempheader.substring(0, colonposition);
						var temppopulation = tempheader.substring((colonposition + 2), tempheader.length);
						var checkcohort = checkedcohorts.indexOf(tempcohort);
						var checkpopulation = checkedparameters.indexOf(temppopulation);
						if (checkcohort > -1 && checkpopulation > -1)
							{
								////Check To See About Adding Spacer Column////
								var CurrentParameter = temppopulation;
								if (CurrentParameter !== PreviousParameter && PreviousParameter !== null)
									{
										var valuecolumn = spacercolumnposition;
										var lowintervalcolumn = spacercolumnposition + 2;
										var highintervalcolumn = spacercolumnposition + 3;
										var stylecolumn = spacercolumnposition + 4;
										var annotationcolumn = spacercolumnposition + 5;
										ColumnsToShow.push(valuecolumn, lowintervalcolumn, highintervalcolumn, stylecolumn, annotationcolumn);
										ColumnsToShow.push(valuecolumn, lowintervalcolumn, highintervalcolumn, stylecolumn, annotationcolumn);													
										ColumnsToShow.push(valuecolumn, lowintervalcolumn, highintervalcolumn, stylecolumn, annotationcolumn);
										ColumnsToShow.push(valuecolumn, lowintervalcolumn, highintervalcolumn, stylecolumn, annotationcolumn);	
									}

								if (CurrentParameter !== PreviousParameter)
									{
										var valuecolumn = count;
										var lowintervalcolumn = count + 2;
										var highintervalcolumn = count + 3;
										var stylecolumn = count + 4;
										var annotationcolumn = count + 5;
										ColumnsToShow.push(valuecolumn, lowintervalcolumn, highintervalcolumn, stylecolumn, annotationcolumn);													
									}
								
								else
									{			
										var valuecolumn = count;
										var lowintervalcolumn = count + 2;
										var highintervalcolumn = count + 3;
										var stylecolumn = count + 4;
										var annotationcolumn = spacercolumnposition + 5;
										ColumnsToShow.push(valuecolumn, lowintervalcolumn, highintervalcolumn, stylecolumn, annotationcolumn);
									}

								var PreviousParameter = temppopulation;
							}
					}
				count++;
			}
		if (ColumnsToShow.length < 2)
			{
				alert("Unable to determine appropriate Cohort: Parameter column positions. You will now see a default selection.")
				var firstpopulationposition = determinefirstpopulationposition(MasterTreatmentCohortArrayGOOGLE);
				ColumnsToShow.push(firstpopulationposition, (firstpopulationposition + 2), (firstpopulationposition + 3), (firstpopulationposition + 4), (firstpopulationposition + 5));
			}		

		var RowsandColumns = [RowsToShow, ColumnsToShow];
		return RowsandColumns;
	}









////////////////Functions to Create DataTable for Google Charts//////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////Functions to Create DataTable for Google Charts//////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////Functions to Create DataTable for Google Charts//////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////Functions to Create DataTable for Google Charts//////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////Functions to Create DataTable for Google Charts//////////////////////////////////////////////////////////////////////////////////////////////////////


/////Create Columns for Google Scatter Chart (Outcomes Analysis)///////
/////Create Columns for Google Scatter Chart (Outcomes Analysis)///////
function createcolumnsforgooglescatterchart(MasterOutcomesArray, PopulationData) {
 	
	//Column Creation
	PopulationData.addColumn('string', 'PatientID');
				
	//Column Creation Loop
	var count = 1;
	while (count < MasterOutcomesArray[0].length) 
		{
					var selectedheadervalue = MasterOutcomesArray[0][count];
					
					var outcomesindexcheck = -1;
					var populationindexcheck = -1;
					var groupsindexcheck = -1;
					var cancertypecheck = -1;
					var treatmentcheck = -1;
					var cancertreatpaircheck = -1;
					var stylecheck1 = -1;
					var stylecheck2 = -1;
					
					var outcomesindexcheck = selectedheadervalue.indexOf("Outcomes");
					var populationindexcheck = selectedheadervalue.indexOf(":");
					var groupsindexcheck = selectedheadervalue.indexOf("Group -");
					var cancertypecheck = selectedheadervalue.indexOf("CancerType");
					var treatmentcheck = selectedheadervalue.indexOf("Treatment");
					var cancertreatpaircheck = selectedheadervalue.indexOf("CancerTreatPair");
					var stylecheck1 = selectedheadervalue.indexOf("Style1");
					var stylecheck2 = selectedheadervalue.indexOf("Style2");

					if (outcomesindexcheck > -1 || populationindexcheck > -1) {
						PopulationData.addColumn('number', MasterOutcomesArray[0][count]);
						var typereport = typeof MasterOutcomesArray[1][count];
						var testreport = "The column: " + MasterOutcomesArray[0][count] + " has been added as a number. The inserted value is a " + typereport;
					}
					
					if (groupsindexcheck > -1 || cancertypecheck > -1 || treatmentcheck > -1 || cancertreatpaircheck > -1)
						{
							PopulationData.addColumn('string', MasterOutcomesArray[0][count]);
							var typereport = typeof MasterOutcomesArray[1][count];
							var testreport = "The column: " + MasterOutcomesArray[0][count] + " has been added as a string. The inserted value is a " + typereport;
						}
					
					if (stylecheck1 > -1)
						{
							PopulationData.addColumn({type:'string', role:'style'});
						}
					
					if (stylecheck2 > -1)
						{
							PopulationData.addColumn({type:'string', role:'style'});
						}					
					count++;
		}
		
		return PopulationData;
}


/////Populate Rows into Google Scatter Chart//////
/////Populate Rows into Google Scatter Chart//////
function populaterowsintogooglescatterchart(MasterOutcomesArray, PopulationData) {
	var count = 1;
	while (count < MasterOutcomesArray.length) 
		{
			var RowArray = MasterOutcomesArray[count];
			PopulationData.addRow(RowArray);
			count++;
		}
	
	return PopulationData;
}



////Function to Construct Master Treatment-Cohort Array Headers/////////////////////
////Function to Construct Master Treatment-Cohort Array Headers/////////////////////
////Function to Construct Master Treatment-Cohort Array Headers/////////////////////
function constructMasterTreatmentCohortArrayHeaders(cohortpopulationoutcomepairs, compositetreatmentpopulationlist) {
	var MasterTreatmentCohortArrayHeaders = [];
	MasterTreatmentCohortArrayHeaders.push("Timepoint");
	MasterTreatmentCohortArrayHeaders.push("Treatment");
	MasterTreatmentCohortArrayHeaders.push("Group Subset");

	var count = 0;
	while (count < cohortpopulationoutcomepairs.length)
		{
			MasterTreatmentCohortArrayHeaders.push(cohortpopulationoutcomepairs[count]);
			MasterTreatmentCohortArrayHeaders.push("All Values");
			MasterTreatmentCohortArrayHeaders.push("Low Interval");
			MasterTreatmentCohortArrayHeaders.push("High Interval");
			MasterTreatmentCohortArrayHeaders.push("Style");
			MasterTreatmentCohortArrayHeaders.push("Annotation");
			MasterTreatmentCohortArrayHeaders.push("More Info");
			count++;
		}
	
	var count = 0;
	while (count < compositetreatmentpopulationlist.length)
		{
			MasterTreatmentCohortArrayHeaders.push(compositetreatmentpopulationlist[count]);
			MasterTreatmentCohortArrayHeaders.push("All Values");
			MasterTreatmentCohortArrayHeaders.push("Low Interval");
			MasterTreatmentCohortArrayHeaders.push("High Interval");
			MasterTreatmentCohortArrayHeaders.push("Style");
			MasterTreatmentCohortArrayHeaders.push("Annotation");
			MasterTreatmentCohortArrayHeaders.push("More Info");
			count++;
		}		
	
	//////////Add Spacer Columns//////
			MasterTreatmentCohortArrayHeaders.push("SPACER COLUMN");
			MasterTreatmentCohortArrayHeaders.push("All Values");
			MasterTreatmentCohortArrayHeaders.push("Low Interval");
			MasterTreatmentCohortArrayHeaders.push("High Interval");
			MasterTreatmentCohortArrayHeaders.push("Style");
			MasterTreatmentCohortArrayHeaders.push("Annotation");
			MasterTreatmentCohortArrayHeaders.push("More Info");	
	
	
	return MasterTreatmentCohortArrayHeaders;
}











//////Function to Initialize Column Chart (Google)//////////////////////////////////////////////////////////////////////////////
//////Function to Initialize Column Chart (Google)//////////////////////////////////////////////////////////////////////////////
//////Function to Initialize Column Chart (Google)//////////////////////////////////////////////////////////////////////////////
//////Function to Initialize Column Chart (Google)//////////////////////////////////////////////////////////////////////////////
function initializeChart(MasterTreatmentCohortArrayGOOGLE, MasterTreatmentCohortArray, populationlist, timepointlist, outcomeslist, appendedcancertypetreatmentpairlist, cancertypetreatmentpairlist, groupsparentchildlist, cancertypelist) {
		
	var PopulationData = new google.visualization.DataTable();

	//Column Creation
	PopulationData.addColumn('string', 'Timepoint');
	
	//Column Creation Loop
	var count = 1;
	while (count < MasterTreatmentCohortArrayGOOGLE[0].length) 
		{
			var selectedheadervalue = MasterTreatmentCohortArrayGOOGLE[0][count];
			
			var populationindexcheck = -1;
			var populationindexcheck = selectedheadervalue.indexOf(":");
					
			if (selectedheadervalue == "Treatment")
				{
					PopulationData.addColumn({type:'string', role:'style'});
				}

			if (selectedheadervalue == "Group Subset")
				{
					PopulationData.addColumn({type:'string', role:'style'});
				}					
				
			if (populationindexcheck > -1) 
				{
					PopulationData.addColumn('number', MasterTreatmentCohortArrayGOOGLE[0][count]);
					PopulationData.addColumn({type:'string', role:'style'});
					PopulationData.addColumn({type:'number', role:'interval'});
					PopulationData.addColumn({type:'number', role:'interval'});
					PopulationData.addColumn({type:'string', role:'style'});
					PopulationData.addColumn({type:'string', role:'annotation'});
					PopulationData.addColumn({type:'string', role:'annotationText'});
				}

			if (selectedheadervalue == "SPACER COLUMN") 
				{
					//alert("Found the Spacer Column");
					PopulationData.addColumn('number', "SPACER COLUMN");
					PopulationData.addColumn({type:'string', role:'style'});
					PopulationData.addColumn({type:'number', role:'interval'});
					PopulationData.addColumn({type:'number', role:'interval'});
					PopulationData.addColumn({type:'string', role:'style'});
					PopulationData.addColumn({type:'string', role:'annotation'});
					PopulationData.addColumn({type:'string', role:'annotationText'});
				}

			
			count++;
		}

	///////Row Creation Loop//////
	var count = 1;
	while (count < MasterTreatmentCohortArrayGOOGLE.length) 
		{
			var RowArray = MasterTreatmentCohortArrayGOOGLE[count];
			PopulationData.addRow(RowArray);
			count++;
		}
	
	
	//Create Data View
	var PopulationChartDataView = new google.visualization.DataView(PopulationData);
	var firstpopulationposition = determinefirstpopulationposition(MasterTreatmentCohortArrayGOOGLE);
	var ColumnsToShow = [0,firstpopulationposition,(firstpopulationposition + 2),(firstpopulationposition + 3),(firstpopulationposition + 4),(firstpopulationposition + 5)];
	var RowsToShow = [0];

	PopulationChartDataView.setColumns(ColumnsToShow);
	PopulationChartDataView.setRows(RowsToShow);

///////Acquire Canvas
	var chart = new google.visualization.ColumnChart(document.getElementById('linechart_material'));  
	var checkedparameters = [];
	checkedparameters.push(populationlist[0]);
	
///////Chart Options//////
	var options = updateoptionsCOLUMNCHART(MasterTreatmentCohortArrayGOOGLE, ColumnsToShow, RowsToShow, checkedparameters);

	function drawChart(x, y, RowsToShow, ColumnsToShow) {
			
			google.visualization.events.removeAllListeners(chart);
			
			update.disabled = false;
			google.visualization.events.addListener(chart, 'ready',
			function() {
				update.disabled = false;
			});
			
			
			//////Listener To Display Selection Info///////				
			function selectHandlerCOLUMN() {
				  var selectedItemPosition = [];
				  var selectedItem = chart.getSelection()[0];
				  if (selectedItem)
					{			
						var SelectedItemRow = selectedItem.row;
						var SelectedItemRow = RowsToShow[SelectedItemRow];
						
						var SelectedItemColumn = selectedItem.column;
						var SelectedItemColumn = ColumnsToShow[SelectedItemColumn];
						updateselectioninfo(SelectedItemRow, SelectedItemColumn, MasterTreatmentCohortArray);
						//alert("Row: " + SelectedItemRow + " and Column: " + SelectedItemColumn);
					}
			}			
					
			google.visualization.events.addListener(chart, 'select', selectHandlerCOLUMN);
			
			chart.draw(x, y);
			
	};

	/////Draw the Chart
		
	drawChart(PopulationChartDataView, options, RowsToShow, ColumnsToShow);
	
		
		
	/////////Update Button Functions////////////
	/////////Update Button Functions////////////
	/////////Update Button Functions////////////

	update.onclick = function() {	
		
		//Determine Which Timepoints Are Selected
		var checkedtimepoints = determineselectedtimepoints(timepointlist);

		//Determine Which Parameters Are Selected
		var checkedparameters = determineselectedparametersCOLUMN(populationlist, outcomeslist);

		/////////Determine Which Cohorts Are Selected for COLUMN CHART////////		
		if (cancertypelist.length > 1)
			{
				var tempcohortslist = appendedcancertypetreatmentpairlist;
			}
		else
			{
				var tempcohortslist = cancertypetreatmentpairlist;
			}
		var checkedcohorts = determineselectedcohortsNOROWS(tempcohortslist);


		//////////Determine which groups are selected for COLUMN CHART/////////////
		var checkedgroups = defineselectedgroupsCOLUMN(groupsparentchildlist);
		

		////Define Subset Selection Filter for Column Chart//////
		var SubsetSelectionFilter = [checkedtimepoints, checkedparameters, checkedcohorts, ["ALL"], checkedgroups];


		/////Define Rows and Columns to Show for Google COLUMN CHART////////////////////////////////////////////////////////
		var RowsandColumnsToShow = definerowsandcolumnstoshowforcolumnchart(SubsetSelectionFilter, MasterTreatmentCohortArray);
		var RowsToShow = RowsandColumnsToShow[0];
		var ColumnsToShow = RowsandColumnsToShow[1];

		//////Update COLUMN CHART Options//////
		var options = updateoptionsCOLUMNCHART(MasterTreatmentCohortArrayGOOGLE, ColumnsToShow, RowsToShow, checkedparameters);

		//////Redraw Chart//////
		PopulationChartDataView.setRows(RowsToShow);
		PopulationChartDataView.setColumns(ColumnsToShow);
		drawChart(PopulationChartDataView, options, RowsToShow, ColumnsToShow);

	////End of update button function///
	}
};


















































































///////Copy Array to String////
//function copyarraytostring(newbasearray) {
//var arraystringcopy = "[";
//var count = 0;
//while (count < newbasearray.length)
//	{
//		arraystringcopy += "[";
//		
//		var count2 = 0;
//		while (count2 < newbasearray[count].length)
//			{
//				var selectedelement = "'" + newbasearray[count][count2] + "',";
//				arraystringcopy += selectedelement;
//				count2++;
//			}
//		arraystringcopy = arraystringcopy.slice(0, -1);
//		arraystringcopy += "],";
//		count++;
//	}
//arraystringcopy = arraystringcopy.slice(0, -1);
//arraystringcopy += "];";
// }





















//////Function to Process newbasearray for COLUMN CHART ANALYSIS///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////Function to Process newbasearray for COLUMN CHART ANALYSIS///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////Function to Process newbasearray for COLUMN CHART ANALYSIS///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////Function to Process newbasearray for COLUMN CHART ANALYSIS///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////Function to Process newbasearray for COLUMN CHART ANALYSIS///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////Function to Process newbasearray for COLUMN CHART ANALYSIS///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////Function to Process newbasearray for COLUMN CHART ANALYSIS///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////Function to Process newbasearray for COLUMN CHART ANALYSIS///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////Function to Process newbasearray for COLUMN CHART ANALYSIS///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

function analyzeArray(newbasearray) {
	statusobject.status = "Building Visualization";
	statusupdate();
	
	///////////Timepoint Module////////////////
	var timepointposition = determinetimepointposition(newbasearray);

	//Calculate Number of Timepoints and Construct List/////
	var timepointlist = createsortedtimepointlistwithdifferentials(newbasearray, timepointposition);

	/////////Patient Module///////////////
	//Determine Patient Position
	var patientposition = determinepatientposition(newbasearray);

	//Calculate Number of Patients and Construct List
	var patientlist = createsortedpatientlist(newbasearray, patientposition);

	///////////Population Module///////////////////////// 
	//Calculate Number of Populations and Construct Sorted List
	var sortedpopulationlistarray = createsortedpopulationlistarray(newbasearray);
	var populationlist = sortedpopulationlistarray[0];
	var populationlistindex = sortedpopulationlistarray[1];

	//Calculate Number of Outcomes and Construct List//
	var allthreeoutcomesarrays = createsortedoutcomeslistarray(newbasearray);
	var outcomeslist = allthreeoutcomesarrays[0];
	var outcomeslistindex = allthreeoutcomesarrays[1];

	/////////  Groups Module //////////////////// 
	//Calculate Number of Groups and Construct List
	var allthreegroupsarray = createsortedgroupslistarray(newbasearray);
	var groupslist = allthreegroupsarray[0];
	var groupslistindex = allthreegroupsarray[1];
	var groupsparentchildlist = allthreegroupsarray[3];
	

	/////////Cancer Type Module///////////////
	///Determine CancerType Position////
	var cancertypeposition = determinecancertypeposition(newbasearray);

	//Calculate Number of Cancer Types and Construct List
	var cancertypelist = createsortedcancertypelist(newbasearray, cancertypeposition);
	
	/////////Treatment Module///////////////
	//Determine Treatment Position
	var treatmentposition = determinetreatmentposition(newbasearray);

	//Calculate Number of Treatments and Construct List
	var treatmentlist = createsortedtreatmentlist(newbasearray, treatmentposition);


	/////////CancerType-Treatment Pairs Module (Create Cohorts)///////////////
	//Calculate Number of Treatments and Construct List
	var cancertypetreatmentpairlist = createcancertypetreatmentpairlist(newbasearray, cancertypeposition, treatmentposition);

	///////////////Timepoint-Parameter Module/////////////////////
	//Build Array Headers (Timepoint-Parameter) List
	var timepointparameterpairslist = createtimepointparameterpairslist(timepointlist, populationlist);
	

///////Construct List of Cohort-Outcome/Population Pairs Array Headers (Timepoint-Parameter) List///////////
var cohortpopulationoutcomepairs = createcohortpopulationoutcomepairlist(cancertypetreatmentpairlist, outcomeslist, populationlist, treatmentlist);


/////////////Create Composite Treatment-Population/Outcomes List for COLUMN CHART/////
var compositetreatmentpopulationlist = createcompositetreatmentpopulationoutcomeslistforCOLUMNCHART(treatmentlist, populationlist, outcomeslist);

	
/////Create Appended (CancerType and Composite) Treatment Pair List//////////
var appendedcancertypetreatmentpairlist = createappendedcancertypewithcompositetreatmentpairlist(cancertypetreatmentpairlist, treatmentlist);

////Create Simple Treatment Colors Array////
var NEWCancerTypeTreatmentShapeColorFormats = createsimpletreatmentcolorslist(appendedcancertypetreatmentpairlist, treatmentcolorsarray, treatmentlist, cancertypeshapesarrayhtmlcodes, cancertypelist, cancertypecolorsarray);

////Function to Construct Master Treatment-Cohort Array Headers/////////////////////
var MasterTreatmentCohortArrayHeaders = constructMasterTreatmentCohortArrayHeaders(cohortpopulationoutcomepairs, []);

////Update Status////
var sizeassessor = cohortpopulationoutcomepairs.length * groupslist.length * patientlist.length * timepointlist.length;
var sizeassessor = sizeassessor / 2;
var timeestimate = Math.round(sizeassessor / 5000000);
if (sizeassessor > 2600000) {
	alert("You are building an interactive visualization with at least " + sizeassessor + " values. This is expected to take ~" + timeestimate + " minute(s). Please do not close the browser or Kill the Javascript program.");
	}

////Function to Construct Master Treatment-Cohort Array for COLUMN CHART/////////////////////
var BothMasterTreatmentCohortArrays = createmastertreatmentcohortarray(newbasearray, MasterTreatmentCohortArrayHeaders, timepointlist, timepointposition, patientposition, treatmentlist, treatmentposition, groupsparentchildlist, populationlist, populationlistindex, outcomeslist, outcomeslistindex, groupslist, groupslistindex, cancertypeposition, NEWCancerTypeTreatmentShapeColorFormats);
var MasterTreatmentCohortArray = BothMasterTreatmentCohortArrays[0];
var MasterTreatmentCohortArrayGOOGLE = BothMasterTreatmentCohortArrays[1];

//////Function to Initialize Column Chart (Google)//////////////////////////////////////////////////////////////////////////////
initializeChart(MasterTreatmentCohortArrayGOOGLE, MasterTreatmentCohortArray, populationlist, timepointlist, outcomeslist, appendedcancertypetreatmentpairlist, cancertypetreatmentpairlist, groupsparentchildlist, cancertypelist);


//// Build Selection Checkboxes //////
//// Build Selection Checkboxes //////
/////Build Timepoint Selection Boxes/////
var timepointcheckboxeshtml = buildtimepointselectionboxes(timepointlist);
$("#timepoints").html(timepointcheckboxeshtml);

//////Build Cohort Selection Boxes//////			
if (cancertypelist.length > 1)
	{
		var tempcohortlist = appendedcancertypetreatmentpairlist;
	}
else 
	{
		var tempcohortlist = cancertypetreatmentpairlist;
	}

var cancertreatpaircheckboxeshtml = buildcohortselectionboxes(tempcohortlist, NEWCancerTypeTreatmentShapeColorFormats);
$("#cohortselectors").html(cancertreatpaircheckboxeshtml);

/////Build Parameter Selection Boxes/////
var parametercheckboxeshtml = buildparameterselectionboxesCOLUMN(populationlist, outcomeslist);
$("#parameters").html(parametercheckboxeshtml);

/////Build Group Selection Boxes////
var groupscheckboxeshtml = buildgroupselectionboxesCOLUMN(groupsparentchildlist);
$("#groupselectors").html(groupscheckboxeshtml);



////////Functions for Relationships Data Export/////////////////////////////////////////////////////////////
////////Functions for Relationships Data Export/////////////////////////////////////////////////////////////
////////Functions for Relationships Data Export/////////////////////////////////////////////////////////////
////////Functions for Relationships Data Export/////////////////////////////////////////////////////////////
////////Functions for Relationships Data Export/////////////////////////////////////////////////////////////
////////BUTTON FUNCTIONS to Run Stats Analyses////////
////////BUTTON FUNCTIONS to Run Stats Analyses////////
////////BUTTON FUNCTIONS to Run Stats Analyses////////
///////////////////BUTTONS AND FUNCTIONS TO ANALYZE STATS////////////////////////////////////////////////////////////////////////////
///////////////////BUTTONS AND FUNCTIONS TO ANALYZE STATS////////////////////////////////////////////////////////////////////////////
///////////////////BUTTONS AND FUNCTIONS TO ANALYZE STATS////////////////////////////////////////////////////////////////////////////
///////////////////BUTTONS AND FUNCTIONS TO ANALYZE STATS////////////////////////////////////////////////////////////////////////////
///////////////////BUTTONS AND FUNCTIONS TO ANALYZE STATS////////////////////////////////////////////////////////////////////////////
///////////////////BUTTONS AND FUNCTIONS TO ANALYZE STATS////////////////////////////////////////////////////////////////////////////


/////Groups Analyses/////
/////Groups Analyses////////
$("#RunGroupsANOVA").click(function(MergedGroupsBOTHARRAYS){

	var MergedGroupsBOTHARRAYS = analyzegroupsattimepointparameterANOVA(MasterTreatmentCohortArray, timepointlist, treatmentlist, groupslist, groupsparentchildlist, populationlist, outcomeslist, cancertypetreatmentpairlist);
	var MergedGroupsANOVA = MergedGroupsBOTHARRAYS[0];

	/////Function to Construct Merged Group ANOVA Report for COLUMN CHART/////////////////////////////
	var MergedGroupsANOVAhtml = constructMergedGroupANOVAhtml(MergedGroupsANOVA);
	$("#MergedGroupsANOVArelationships").html(MergedGroupsANOVAhtml);

	//////Export ANOVA Group Relationships//////////
	$("#MergedGroupsANOVAEXPORT").click(function () {
		exportselecteddataset(MergedGroupsANOVA, "GroupsANOVAresults");
	});
});


$("#RunGroupsTTEST").click(function(MergedGroupsBOTHARRAYS){
	var MergedGroupsBOTHARRAYS = analyzegroupsattimepointparameterANOVA(MasterTreatmentCohortArray, timepointlist, treatmentlist, groupslist, groupsparentchildlist, populationlist, outcomeslist, cancertypetreatmentpairlist);
	var MergedGroupsTTEST = MergedGroupsBOTHARRAYS[1];
	
	//////////Function to Construct Group T Test Relationships HTML for COLUMN CHART/////////////////////////////
	var MergedGroupsTTesthtml = constructMergedGroupTTesthtml(MergedGroupsTTEST);
	$("#groupVSgrouprelationships").html(MergedGroupsTTesthtml);	
	
	
	//////Export T-test Group Relationships//////////
	$("#groupVSgroupEXPORT").click(function () {
		exportselecteddataset(MergedGroupsTTEST, "GroupsTTestresults");
	});
});
	

/////Cohort Analyses////////
/////Cohort Analyses////////
$("#RunCohortsANOVA").click(function(MergedCohortsBOTHARRAYS){

	var MergedCohortsBOTHARRAYS = analyzecohortsattimepointparameterANOVA(MasterTreatmentCohortArray, timepointlist, treatmentlist, groupslist, groupsparentchildlist, populationlist, outcomeslist, cancertypetreatmentpairlist);
	var MergedCohortsANOVA = MergedCohortsBOTHARRAYS[0];
	
	////Function to Construct Merged Cohort ANOVA Relationships HTML/////////////////////////////
	var MergedCohortsANOVAhtml = constructMergedCohortANOVAhtml(MergedCohortsANOVA);
	$("#MergedCohortsANOVArelationships").html(MergedCohortsANOVAhtml);
	
	//////Export ANOVA Cohort Relationships//////////
	$("#MergedCohortsANOVAEXPORT").click(function () {
		exportselecteddataset(MergedCohortsANOVA, "CohortsANOVAresults");
	});

});


$("#RunCohortsTTEST").click(function(MergedCohortsBOTHARRAYS){
	var MergedCohortsBOTHARRAYS = analyzecohortsattimepointparameterANOVA(MasterTreatmentCohortArray, timepointlist, treatmentlist, groupslist, groupsparentchildlist, populationlist, outcomeslist, cancertypetreatmentpairlist);
	var MergedCohortsTTEST = MergedCohortsBOTHARRAYS[1];

	//////////Function to Construct Cohort T Test Relationships HTML for COLUMN CHART/////////////////////////////
	var MergedCohortsTTesthtml = constructMergedCohortTTesthtml(MergedCohortsTTEST);
	$("#cohortVScohortrelationships").html(MergedCohortsTTesthtml);	
	
	//////Export T-test Cohort Relationships//////////
	$("#cohortVScohortEXPORT").click(function () {
		exportselecteddataset(MergedCohortsTTEST, "CohortsTTestresults");
	});
});


/////////////Treatment Stats////////////////////////////////////////////////////////////
/////////////Treatment Stats////////////////////////////////////////////////////////////
$("#RunTreatmentsANOVA").click(function(MergedTreatmentClustersBOTHARRAYS){

	var MergedTreatmentClustersBOTHARRAYS = analyzetreatmentsattimepointparameterANOVA(MasterTreatmentCohortArray, timepointlist, treatmentlist, groupslist, groupsparentchildlist, populationlist, outcomeslist, cancertypetreatmentpairlist);
	var MergedTreatmentsANOVA = MergedTreatmentClustersBOTHARRAYS[0];
	
	////Function to Construct Merged Cohort ANOVA Relationships HTML/////////////////////////////
	var MergedTreatmentsANOVAhtml = constructMergedTreatmentANOVAhtml(MergedTreatmentsANOVA);
	$("#TreatmentsANOVArelationships").html(MergedTreatmentsANOVAhtml);
	
	//////Export ANOVA Treatment Relationships//////////
	$("#TreatmentsANOVAEXPORT").click(function () {
		exportselecteddataset(MergedTreatmentsANOVA, "TreatmentsANOVAresults");
	});

});


$("#RunTreatmentsTTEST").click(function(MergedTreatmentClustersBOTHARRAYS){
	var MergedTreatmentClustersBOTHARRAYS = analyzetreatmentsattimepointparameterANOVA(MasterTreatmentCohortArray, timepointlist, treatmentlist, groupslist, groupsparentchildlist, populationlist, outcomeslist, cancertypetreatmentpairlist);
	var MergedTreatmentsTTest = MergedTreatmentClustersBOTHARRAYS[1];

	//////////Function to Construct Cohort T Test Relationships HTML for COLUMN CHART/////////////////////////////
	var MergedTreatmentsTTesthtml = constructMergedTreatmentTTesthtml(MergedTreatmentsTTest);
	$("#treatmentVStreatmentrelationships").html(MergedTreatmentsTTesthtml);	
	
	//////Export T-test Cohort Relationships//////////
	$("#treatmentVStreatmentEXPORT").click(function () {
		exportselecteddataset(MergedTreatmentsTTest, "TreatmentsTTestresults");
	});
});


}











</script>
</head>
<body>
<div id="bigcontainer" style="width: 90%; height: 85%;padding:5px" >
	<div id="headerbuttons" style="width: 100%; height: 5%;font-size:1vw">
		<table style="width: 100%; height: 100%">
			<tr style="width: 100%; height: 100%">
				<td style="width: 45%">
					<div id="inputs" class="clearfix">
						<input type="file" id="files" name="files[]" multiple=""><b>&larr; Upload CSV file.</b>
					</div>
				</td>
				<td style="width: 45%">
					<div id="selectedpatientinfo">
						Selection Information.
					</div>
				</td>
			</tr>
		</table>
	</div>

	<div style="width: 100%; height: 55%">
		<table style="width: 100%; height: 100%">
			<tr>
				<td>
					<div id='linechart_material' style="height:100%;width:100%"><br><br>If this message is not replaced by a chart after you load your CSV file, you have a problem</div>
				</td>
			</tr>
		</table>
	</div>
	
	<div style="width: 100%; height: 40%">
		<div id="buttondiv" style="width:100%;height:10%;margin:5px;padding:10px">
			<table style="width: 100%; height: 100%">
				<tr style="height:100%">
					<td style="width:30%">
						<button id="update" style="padding:7px;margin:4px;border-radius:10px;background-color:WhiteSmoke;border-color:Black;font-size:0.85vw"><b>Visualize Relationships</b></button>
					</td>
					<td style="width:25%">
						<div id="minimizebaseoptions">
							<button id="hidebaseoptions" style="padding:7px;margin:4px;border-radius:10px;background-color:WhiteSmoke;border-color:Red;font-size:0.85vw"><b>Hide Timepoints/Parameters</b></button>
						</div>
						<div id="maximizebaseoptions" style="display:none">
							<button id="showbaseoptions" style="padding:7px;margin:4px;border-radius:10px;background-color:WhiteSmoke;border-color:Green;font-size:0.85vw"><b>Show Timepoints/Parameters</b></button>
						</div>
					</td>
					<td style="width:15%">
						<div id="groupsHIDDEN" style="">
							<button id="showgroups" style="padding:7px;margin:4px;border-radius:10px;background-color:WhiteSmoke;border-color:Green;font-size:0.85vw"><b>Show Groups</b></button>
						</div>
						<div id="groupsVISIBLE" style="display:none">
							<button id="hidegroups" style="padding:7px;margin:4px;border-radius:10px;background-color:WhiteSmoke;border-color:Red;font-size:0.85vw"><b>Hide Groups</b></button>
						</div>	
					</td>
					<td style="width:15%">
						<div id="cohortsHIDDEN" style="">
							<button id="showcohorts" style="padding:7px;margin:4px;border-radius:10px;background-color:WhiteSmoke;border-color:Green;font-size:0.85vw"><b>Show Cohorts</b></button>
						</div>
						<div id="cohortsVISIBLE" style="display:none">
							<button id="hidecohorts" style="padding:7px;margin:4px;border-radius:10px;background-color:WhiteSmoke;border-color:Red;font-size:0.85vw"><b>Hide Cohorts</b></button>
						</div>	
					</td>
					<td style="width:15%">
						<div id="treatmentsHIDDEN" style="">
							<button id="showtreatments" style="padding:7px;margin:4px;border-radius:10px;background-color:WhiteSmoke;border-color:Green;font-size:0.85vw"><b>Show treatments</b></button>
						</div>
						<div id="treatmentsVISIBLE" style="display:none">
							<button id="hidetreatments" style="padding:7px;margin:4px;border-radius:10px;background-color:WhiteSmoke;border-color:Red;font-size:0.85vw"><b>Hide treatments</b></button>
						</div>	
					</td>
				</tr>
			</table>
		</div>

		<div id="baseoptionsdiv" style="width: 100%; height: 80%">
			<table style="width: 100%; height: 100%">
				<tr style="height:15%">								
					<td style="padding:5px;background-color:Gainsboro;vertical-align:top;border-radius:10px;width:40%;font-size:.9vw">
						<em><b>Timepoints</b></em>
					</td>
					
					<td  style="padding:5px;background-color:PaleGreen;vertical-align:top;border-radius:10px;width:60%;font-size:.9vw">
						<em><b>Parameters</b></em>
					</td>
				</tr>
							
				<tr style="height:85%">							
					<td style="padding:5px;background-color:Gainsboro;vertical-align:top;border-radius:10px;width:40%">
						<div style="height:100%;overflow: auto;font-size:1vw">
							<div id="timepoints">
								This is where timepoints will be populated.
							</div>
						</div>
					</td>
					
					<td style="padding:5px;background-color:PaleGreen;vertical-align:top;border-radius:10px;width:60%">
						<div style="height:100%;overflow: auto;font-size:1vw">
							<div id="parameters">
							This is where the parameters will be populated.
							</div>
						</div>
					</td>	
				</tr>
			</table>
		</div>

		<div id="groupstatsandoptions" style="width:100%;height:80%;display:none">
			<table style="width:100%;height:100%">
				<tr style="height:15%">
					<td style="padding:5px;background-color:PowderBlue;vertical-align:top;border-radius:10px;width:30%;font-size:.9vw">
						<em><b>Group Subsets</b></em>
					</td>
					<td style="padding:5px;background-color:Khaki;vertical-align:top;border-radius:10px;width:35%;font-size:.9vw">
						<em><b>Parent Group Analysis (ANOVA)</b></em>&#32;&#32;&#32;&#32;<button id="MergedGroupsANOVAEXPORT" style="padding:4px;border-radius:10px;background-color:WhiteSmoke;border-color:Black;font-size:.8vw"><b>Export </b></button> <button id="RunGroupsANOVA" style="padding:4px;border-radius:10px;background-color:WhiteSmoke;border-color:Black;font-size:.8vw"><b>Run Analysis</b></button>
					</td>
					<td style="padding:5px;background-color:Pink;vertical-align:top;border-radius:10px;width:35%;font-size:.9vw">
						<em><b>Sub-Group Comparisons (T-test)</b></em>&#32;&#32;&#32;&#32;<button id="groupVSgroupEXPORT" style="padding:4px;border-radius:10px;background-color:WhiteSmoke;border-color:Black;font-size:.8vw"><b>Export </b></button> <button id="RunGroupsTTEST" style="padding:4px;border-radius:10px;background-color:WhiteSmoke;border-color:Black;font-size:.8vw"><b>Run Analysis</b></button>
					</td>			
				</tr>
				
				<tr style="height:85%">
					<td style="padding:5px;background-color:PowderBlue;vertical-align:top;border-radius:10px;width:30%">
						<div style="height:100%;overflow: auto;font-size:1vw">
							<div id="groupselectors">
								This is where group selection options will be populated
							</div>
						</div>			
					</td>
					<td style="padding:5px;background-color:Khaki;vertical-align:top;border-radius:10px;width:35%">
						<div style="height:100%;overflow: auto;font-size:1vw">
							<div id="MergedGroupsANOVArelationships">
								ANOVA analysis of differences between the sub-groups within each parent group for each parameter-timepoint-treatment combination. This analysis does not take into account the Cancer Type.
							</div>
						</div>
					</td>
					<td style="padding:5px;background-color:Pink;vertical-align:top;border-radius:10px;width:35%">
						<div style="height:100%;overflow: auto;font-size:1vw">
							<div id="groupVSgrouprelationships">
								T-test comparison of sub-groups within each parent group for each parameter-timepoint-treatment combination. This analysis does not take into account the Cancer Type.
							</div>
						</div>
					</td>
				</tr>
			</table>
		</div>

		<div id="cohortstatsandoptions" style="width:100%;height:80%;display:none">
			<table style="width:100%;height:100%">
				<tr style="height:15%">
					<td style="padding:5px;background-color:PowderBlue;vertical-align:top;border-radius:10px;width:30%;font-size:.9vw">
						<em><b>Cohorts</b></em>
					</td>
					<td style="padding:5px;background-color:Khaki;vertical-align:top;border-radius:10px;width:35%;font-size:.9vw">
						<em><b>Cohort Analysis (ANOVA)</b></em>&#32;&#32;&#32;&#32;<button id="MergedCohortsANOVAEXPORT" style="padding:4px;border-radius:10px;background-color:WhiteSmoke;border-color:Black;font-size:.8vw"><b>Export </b></button> <button id="RunCohortsANOVA" style="padding:4px;border-radius:10px;background-color:WhiteSmoke;border-color:Black;font-size:.8vw"><b>Run Analysis</b></button>
					</td>
					<td style="padding:5px;background-color:Pink;vertical-align:top;border-radius:10px;width:35%;font-size:.9vw">
						<em><b>Cohort Comparisons (T-test)</b></em>&#32;&#32;&#32;&#32;<button id="cohortVScohortEXPORT" style="padding:4px;border-radius:10px;background-color:WhiteSmoke;border-color:Black;font-size:.8vw"><b>Export </b></button> <button id="RunCohortsTTEST" style="padding:4px;border-radius:10px;background-color:WhiteSmoke;border-color:Black;font-size:.8vw"><b>Run Analysis</b></button>
					</td>			
				</tr>
				
				<tr style="height:85%">
					<td style="padding:5px;background-color:PowderBlue;vertical-align:top;border-radius:10px;width:30%">
						<div style="height:100%;overflow: auto;font-size:1vw">
							<div id="cohortselectors">
								This is where cohort selection options will be populated
							</div>
						</div>			
					</td>
					<td style="padding:5px;background-color:Khaki;vertical-align:top;border-radius:10px;width:35%">
						<div style="height:100%;overflow: auto;font-size:1vw">
							<div id="MergedCohortsANOVArelationships">
								ANOVA analysis of differences between cohorts for each parameter-timepoint combination. This analysis does not take into account Groups.
							</div>
						</div>
					</td>
					<td style="padding:5px;background-color:Pink;vertical-align:top;border-radius:10px;width:35%">
						<div style="height:100%;overflow: auto;font-size:1vw">
							<div id="cohortVScohortrelationships">
								T-test comparison of cohorts for each parameter-timepoint combination. This analysis does not take into account Groups.
							</div>
						</div>
					</td>
				</tr>
			</table>
		</div>

		<div id="treatmentstatsandoptions" style="width:100%;height:80%;display:none">
			<table style="width:100%;height:100%">
				<tr style="height:15%">
					<td style="padding:5px;background-color:PowderBlue;vertical-align:top;border-radius:10px;width:30%;font-size:.9vw">
						<em><b>Treatments</b></em>
					</td>
					<td style="padding:5px;background-color:Khaki;vertical-align:top;border-radius:10px;width:35%;font-size:.9vw">
						<em><b>Treatment Analysis (ANOVA)</b></em>&#32;&#32;&#32;&#32;<button id="TreatmentsANOVAEXPORT" style="padding:4px;border-radius:10px;background-color:WhiteSmoke;border-color:Black;font-size:.8vw"><b>Export </b></button> <button id="RunTreatmentsANOVA" style="padding:4px;border-radius:10px;background-color:WhiteSmoke;border-color:Black;font-size:.8vw"><b>Run Analysis</b></button>
					</td>
					<td style="padding:5px;background-color:Pink;vertical-align:top;border-radius:10px;width:35%;font-size:.9vw">
						<em><b>Treatment Comparisons (T-test)</b></em>&#32;&#32;&#32;&#32;<button id="treatmentVStreatmentEXPORT" style="padding:4px;border-radius:10px;background-color:WhiteSmoke;border-color:Black;font-size:.8vw"><b>Export </b></button> <button id="RunTreatmentsTTEST" style="padding:4px;border-radius:10px;background-color:WhiteSmoke;border-color:Black;font-size:.8vw"><b>Run Analysis</b></button>
					</td>			
				</tr>
				
				<tr style="height:85%">
					<td style="padding:5px;background-color:PowderBlue;vertical-align:top;border-radius:10px;width:30%">
						<div style="height:100%;overflow: auto;font-size:1vw">
							<div id="treatmentselectors">
								This is where treatment selection options will be populated
							</div>
						</div>			
					</td>
					<td style="padding:5px;background-color:Khaki;vertical-align:top;border-radius:10px;width:35%">
						<div style="height:100%;overflow: auto;font-size:1vw">
							<div id="TreatmentsANOVArelationships">
								ANOVA analysis of differences between treatments for each parameter-timepoint combination. This analysis does not take into account Groups or Cancer Type.
							</div>
						</div>
					</td>
					<td style="padding:5px;background-color:Pink;vertical-align:top;border-radius:10px;width:35%">
						<div style="height:100%;overflow: auto;font-size:1vw">
							<div id="treatmentVStreatmentrelationships">
								T-test comparison of treatments for each parameter-timepoint combination. This analysis does not take into account Groups or Cancer Type.
							</div>
						</div>
					</td>
				</tr>
			</table>
		</div>

		<div>
		<a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/80x15.png" /></a><br /><span xmlns:dct="http://purl.org/dc/terms/" property="dct:title">Biomarkers, Outcomes and Stats Software (BOSS)</span> by <a xmlns:cc="http://creativecommons.org/ns#" href="http://www.mycancerproject.org/boss/" property="cc:attributionName" rel="cc:attributionURL">M McNamara, Redmond Lab, EACRI, Providence Cancer Center (Portland, OR)</a> is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>. 
		</div>


	</div>
</div>
</body>
</html>





